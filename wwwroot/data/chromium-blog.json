[
    {
        "title": "Chrome 95 Beta: Secure Payment Confirmation, WebAssembly Exception Handling and More",
        "link": "http://blog.chromium.org/2021/09/chrome-95-beta-secure-payment.html",
        "pubDate": "2021-09-23T23:37:00.003Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D76\">ChromeStatus.com</a>. Chrome 95 is beta as of September 23, 2021.</p> <h2>Origin Trials</h2><p>This version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h3>New Origin Trials</h3> <h4>Access Handles for the File System Access API</h4><p>It's our <a href=\"https://github.com/WICG/storage-foundation-api-explainer/issues/4#issuecomment-853370759\">eventual goal</a> to merge the origin private file system of the File System Access API with the <a href=\"https://chromestatus.com/feature/5670244905385984\">Storage Foundation API</a> to reduce the number of entry points for getting access to file-based storage in the browser. A first step toward this objective is the newly proposed <a href=\"https://github.com/WICG/file-system-access/blob/main/AccessHandle.md\">access handle</a>. The new feature differs from existing functionality by offering in-place and exclusive write access to a file's content. This change, along with the ability to consistently read unflushed modifications and the availability of a synchronous variant on dedicated workers, significantly improves performance and unblocks new use cases. To join the origin trial, see <a href=\"https://www.google.com/url?q=https://developer.chrome.com/origintrials/%23/view_trial/3378825620434714625&amp;sa=D&amp;source=editors&amp;ust=1632322938025000&amp;usg=AOvVaw2QHjz5Bm-HjLWnHt1xaJH3\">its entry on Chrome Origin Trials</a>. For more on access handlers, see the information we've added to <a href=\"https://web.dev/file-system-access/#accessing-storage-foundation-api-files-from-the-origin-private-file-system\">The File System Access API: simplifying access to local files</a>.</p> <h4>Reduce User Agent String Information</h4><p>Chrome is trying to <a href=\"https://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-dates.html\">reduce the amount of information the user agent string exposes</a> in HTTP requests as well as in <code>navigator.userAgent</code>, <code>navigator.appVersion</code>, and <code>navigator.platform</code>. The user agent string can be used for passive user fingerprinting. To join the origin trial, see <a href=\"https://www.google.com/url?q=https://developer.chrome.com/origintrials/%23/view_trial/-7123568710593282047&amp;sa=D&amp;source=editors&amp;ust=1632322938025000&amp;usg=AOvVaw207ZCzhuIHuw9cXAfgBMMn\">its entry on Chrome Origin Trials</a>.</p> <h3>Completed Origin Trials</h3><p>The following features, previously in a Chrome origin trial, are now enabled by default.</p> <h4>Secure Payment Confirmation</h4><p><a href=\"https://www.chromestatus.com/feature/5702310124584960\">Secure payment confirmation</a> augments the payment authentication experience on the web with the help of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API\">Web Authentication API</a>. The feature adds a new 'payment' extension to that API, which allows a relying party such as a bank to opt-in to creating a <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential\">PublicKeyCredential</a></code> that can be queried by any merchant origin as part of an online checkout via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API\">Payment Request API</a> using the <code>'secure-payment-confirmation'</code> payment method.</p> <p>This feature enables a consistent, low friction, strong authentication experience using platform authenticators. Strong authentication with the user's bank is becoming a requirement for online payments in many regions, including the European Union. The proposed feature provides a better user experience and stronger security than existing solutions.</p> <h4>WebAssembly Exception Handling</h4><p>WebAssembly <a href=\"https://developer.chrome.com/origintrials/#/view_trial/2393663201947418625\">now provides exception handling</a> support. Exception handling allows code to break control flow when an exception is thrown. The exception can be any that is known by the WebAssembly module, or it may be an unknown exception that was thrown by a called imported function. </p> <h2>Other Features in this Release</h2> <h3>Adding droppedEntriesCount to PerformanceObserver Callback</h3><p>Currently, web developers can call <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/observe\">PerformanceObserver.observe()</a></code> with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/observe#parameters\">buffered option</a> to listen to past and future performance entries about their site. Unfortunately, past entries need to be stored, and there is a buffer size limit. The <code>droppedEntriesCount</code> parameter helps developers know if they may have lost an entry due to storage being full. </p> <p><a href=\"https://www.chromestatus.com/feature/5320666234486784\">The <code>droppedEntriesCount</code> property</a> is one of the options specified as the third parameter of the callback passed in the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/PerformanceObserver\"><code>PerformanceObserver</code> constructor</a>. It provides the number of entries dropped due to the buffer being full. </p> <h3>EyeDropper API</h3><p><a href=\"https://www.chromestatus.com/feature/6304275594477568\">The EyeDropper API</a> provides a browser-supplied eyedropper for the construction of custom color pickers. Creative applications built for the web could benefit from an ability to sample a color from pixels on the screen. Many OS applications, PowerPoint for example, have this ability but are unable to carry it over to their web equivalents.<br /><br />Even though some browsers have eyedropper capability built into <code>&lt;input type=color&gt;</code> elements, web applications are limited in their ability to integrate this into their custom color pickers since the eyedropper is generally accessible only through the non-customizable popup triggered by the <code>&lt;input&gt;</code> element.</p> <h3>New UA platform Version Source on Windows for User Agent Client Hints</h3><p>Chrome has updated the value <a href=\"https://www.chromestatus.com/feature/5080939765956608\">provided by the <code>Sec-CH-UA-Platform-Version</code> on Windows</a> to provide a reasonable level of fidelity to allow sites to identify meaningful Windows platform changes. This enables sites to deliver appropriate binary executables and help content specific to a particular operating system version. The current user agent string and existing <code>Sec-CH-UA-Platform-Version</code> implementation provides the major and minor version Windows components. However, as of Windows 10, Windows generally doesn't increase either of these numbers across significant releases. Notably, Windows 11 does not increase either of these numbers. You can find a table of  value mappings to Windows releases in the <a href=\"https://github.com/WICG/ua-client-hints/commit/5c1be8772eaf3b823c3c07d6baa6d7348a77627d\">UA Client Hints' repo issue 220</a>.</p> <h3>self.reportError()</h3><p>This function, available in windows and workers, <a href=\"https://www.chromestatus.com/feature/5634523220934656\">allows developers to report errors</a> to the console and any global \"error\" event handlers in the same way as an uncaught JavaScript exception. It is mainly useful for custom event-dispatching or callback-manipulating libraries.<br />This allows library developers to report exceptions in the same way the browser does, which is useful when they need custom control over running the callback. </p> <h3>URLPattern</h3><p><a href=\"https://web.dev/urlpattern/\">URLPattern</a> is a new web API that provides operating system support for matching URLs given a pattern string. It can be used in JavaScript directly or by passing patterns to other web platform APIs such as, for example, as a service worker scope. Both web platform features and JavaScript applications often need to match against URLs. Examples include, service worker scopes on the web platform and URL routing in JavaScript frameworks. Past web platform features have individually created their own URL matching mechanisms. JavaScript has relied on libraries such as path-to-regexp.</p> <h2>Deprecations, and Removals</h2><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h3>FTP Support Removed</h3><p>Chrome is <a href=\"https://www.chromestatus.com/feature/6246151319715840\">removing support for FTP URLs</a>. Use of FTP in the browser is sufficiently low that it is no longer viable to invest in improving the existing FTP client. In addition, more capable FTP clients are available on all affected platforms.<br /><br />Google Chrome 72 and later removed support for fetching document subresources over FTP and rendering of top level FTP resources. Currently navigating to FTP URLs results in showing a directory listing or a download depending on the type of resource. A bug in Google Chrome 74 and later resulted in dropping support for accessing FTP URLs over HTTP proxies. Proxy support for FTP was removed entirely in Google Chrome 76. In Chrome 86 FTP support was turned off for pre-release channels (Canary and Beta) and experimentally turned off for one percent of stable users, though it could be reenabled via the command line. In Chrome 87 it was turned off for fifty percent of users but could also be enabled through the command line. Since Chrome 88, it was only available through a deprecation trial and is now disabled.</p> <h3>Support for URLs with non-IPv4 Hostnames Ending in Numbers</h3><p>Most hostnames that aren't valid IPv4 addresses, but end in numbers are treated as valid, and looked up via DNS (for example, <code>http://foo.127.1/</code>). Per the Public Suffix List spec, the eTLD+1 of the hostname in that URL should be <code>127.1</code>. If that is ever fed back into a URL, <code>http://127.1/</code> is mapped to <code>http://127.0.0.1/</code> by the URL spec, which seems potentially dangerous. <code>127.0.0.0.1</code> could also potentially be used to confuse users. <a href=\"https://www.chromestatus.com/feature/5679790780579840\">URLs with these hostnames are now rejected</a>.</p> <h3>WebAssembly Cross-Origin Module Sharing</h3><p><a href=\"https://www.chromestatus.com/feature/5650158039597056\">Chrome now deprecates sharing WebAssembly modules</a> between cross-origin, but same-site environments to <a href=\"https://developer.chrome.com/blog/wasm-module-sharing-restricted-to-same-origin/\">allow agent clusters to be scoped to origins long term</a>. </p> <h3>Deprecate U2F API (Cryptotoken)</h3><p>Chrome's legacy U2F API for interacting with security keys is deprecated and beginning a deprecation trial in Chrome 95 wherein the API remains enabled by default, but the trial token will disable the key for participating sites. U2F security keys themselves are not deprecated and will continue to work.</p> <p>Affected sites should migrate to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API\">Web Authentication API</a>. Credentials that were originally registered via the U2F API can be challenged via web authentication. USB security keys that are supported by the U2F API are also supported by the Web Authentication API.</p> <p>U2F is Chrome's original security key API. It allows sites to register public key credentials on USB security keys and challenge them for building phishing-resistant two-factor authentication systems. U2F never became an open web standard and was subsumed by the Web Authentication API (launched in Chrome 67). Chrome never directly supported the FIDO U2F JavaScript API, but rather shipped a component extension called cryptotoken, which exposes an equivalent <code>chrome.runtime.sendMessage()</code> method. U2F and Cryptotoken are firmly in maintenance mode and have encouraged sites to migrate to the Web Authentication API for the last two years.</p> <p>The following timeline is currently planned for deprecation and removal:</p> <h4>Chrome 93</h4><p>Stable as of August 31, 2021. Support added for the googleLegacyAppIdSupport extension.</p> <h4>Chrome 95</h4><p>Beta as of September 23, 2021. The following changes were implemented:</p><ul><li>Gated U2F API requests behind a user permission prompt.</li><li>Logged a deprecation notice in the DevTools console for every request.</li></ul> <h4>Chrome 98</h4><p>Beta expected in early January 2022, stable in February. The deprecation trial will continue, but its behavior will reverse: the API will be disabled by default, but may be kept alive by trial participants.</p> <h4>Chrome 103</h4><div style=\"text-align: left;\">Beta expected in late May 2022, stable in late June. The deprecation trial will end.</div><h4>Chrome 104</h4><div style=\"text-align: left;\">Beta expected in late June 2022, stable in early August. The&nbsp; U2F API will be fully removed.</div>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 95 is beta as of September 23, 2021.\n Origin Trials\nThis version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n Access Handles for the File System Access API\nIt's our eventual goal to merge the origin private file system of the File System Access API with the Storage Foundation API to reduce the number of entry points for getting access to file-based storage in the browser. A first step toward this objective is the newly proposed access handle. The new feature differs from existing functionality by offering in-place and exclusive write access to a file's content. This change, along with the ability to consistently read unflushed modifications and the availability of a synchronous variant on dedicated workers, significantly improves performance and unblocks new use cases. To join the origin trial, see its entry on Chrome Origin Trials. For more on access handlers, see the information we've added to The File System Access API: simplifying access to local files.\n Reduce User Agent String Information\nChrome is trying to reduce the amount of information the user agent string exposes in HTTP requests as well as in navigator.userAgent, navigator.appVersion, and navigator.platform. The user agent string can be used for passive user fingerprinting. To join the origin trial, see its entry on Chrome Origin Trials.\n Completed Origin Trials\nThe following features, previously in a Chrome origin trial, are now enabled by default.\n Secure Payment Confirmation\nSecure payment confirmation augments the payment authentication experience on the web with the help of the Web Authentication API. The feature adds a new 'payment' extension to that API, which allows a relying party such as a bank to opt-in to creating a PublicKeyCredential that can be queried by any merchant origin as part of an online checkout via the Payment Request API using the 'secure-payment-confirmation' payment method.\n This feature enables a consistent, low friction, strong authentication experience using platform authenticators. Strong authentication with the user's bank is becoming a requirement for online payments in many regions, including the European Union. The proposed feature provides a better user experience and stronger security than existing solutions.\n WebAssembly Exception Handling\nWebAssembly now provides exception handling support. Exception handling allows code to break control flow when an exception is thrown. The exception can be any that is known by the WebAssembly module, or it may be an unknown exception that was thrown by a called imported function. \n Other Features in this Release\n Adding droppedEntriesCount to PerformanceObserver Callback\nCurrently, web developers can call PerformanceObserver.observe() with the buffered option to listen to past and future performance entries about their site. Unfortunately, past entries need to be stored, and there is a buffer size limit. The droppedEntriesCount parameter helps developers know if they may have lost an entry due to storage being full. \n The droppedEntriesCount property is one of the options specified as the third parameter of the callback passed in the PerformanceObserver constructor. It provides the number of entries dropped due to the buffer being full. \n EyeDropper API\nThe EyeDropper API provides a browser-supplied eyedropper for the construction of custom color pickers. Creative applications built for the web could benefit from an ability to sample a color from pixels on the screen. Many OS applications, PowerPoint for example, have this ability but are unable to carry it over to their web equivalents.\nEven though some browsers have eyedropper capability built into <input type=color> elements, web applications are limited in their ability to integrate this into their custom color pickers since the eyedropper is generally accessible only through the non-customizable popup triggered by the <input> element.\n New UA platform Version Source on Windows for User Agent Client Hints\nChrome has updated the value provided by the Sec-CH-UA-Platform-Version on Windows to provide a reasonable level of fidelity to allow sites to identify meaningful Windows platform changes. This enables sites to deliver appropriate binary executables and help content specific to a particular operating system version. The current user agent string and existing Sec-CH-UA-Platform-Version implementation provides the major and minor version Windows components. However, as of Windows 10, Windows generally doesn't increase either of these numbers across significant releases. Notably, Windows 11 does not increase either of these numbers. You can find a table of  value mappings to Windows releases in the UA Client Hints' repo issue 220.\n self.reportError()\nThis function, available in windows and workers, allows developers to report errors to the console and any global \"error\" event handlers in the same way as an uncaught JavaScript exception. It is mainly useful for custom event-dispatching or callback-manipulating libraries.\nThis allows library developers to report exceptions in the same way the browser does, which is useful when they need custom control over running the callback. \n URLPattern\nURLPattern is a new web API that provides operating system support for matching URLs given a pattern string. It can be used in JavaScript directly or by passing patterns to other web platform APIs such as, for example, as a service worker scope. Both web platform features and JavaScript applications often need to match against URLs. Examples include, service worker scopes on the web platform and URL routing in JavaScript frameworks. Past web platform features have individually created their own URL matching mechanisms. JavaScript has relied on libraries such as path-to-regexp.\n Deprecations, and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n FTP Support Removed\nChrome is removing support for FTP URLs. Use of FTP in the browser is sufficiently low that it is no longer viable to invest in improving the existing FTP client. In addition, more capable FTP clients are available on all affected platforms.\nGoogle Chrome 72 and later removed support for fetching document subresources over FTP and rendering of top level FTP resources. Currently navigating to FTP URLs results in showing a directory listing or a download depending on the type of resource. A bug in Google Chrome 74 and later resulted in dropping support for accessing FTP URLs over HTTP proxies. Proxy support for FTP was removed entirely in Google Chrome 76. In Chrome 86 FTP support was turned off for pre-release channels (Canary and Beta) and experimentally turned off for one percent of stable users, though it could be reenabled via the command line. In Chrome 87 it was turned off for fifty percent of users but could also be enabled through the command line. Since Chrome 88, it was only available through a deprecation trial and is now disabled.\n Support for URLs with non-IPv4 Hostnames Ending in Numbers\nMost hostnames that aren't valid IPv4 addresses, but end in numbers are treated as valid, and looked up via DNS (for example, http://foo.127.1/). Per the Public Suffix List spec, the eTLD+1 of the hostname in that URL should be 127.1. If that is ever fed back into a URL, http://127.1/ is mapped to http://127.0.0.1/ by the URL spec, which seems potentially dangerous. 127.0.0.0.1 could also potentially be used to confuse users. URLs with these hostnames are now rejected.\n WebAssembly Cross-Origin Module Sharing\nChrome now deprecates sharing WebAssembly modules between cross-origin, but same-site environments to allow agent clusters to be scoped to origins long term. \n Deprecate U2F API (Cryptotoken)\nChrome's legacy U2F API for interacting with security keys is deprecated and beginning a deprecation trial in Chrome 95 wherein the API remains enabled by default, but the trial token will disable the key for participating sites. U2F security keys themselves are not deprecated and will continue to work.\n Affected sites should migrate to the Web Authentication API. Credentials that were originally registered via the U2F API can be challenged via web authentication. USB security keys that are supported by the U2F API are also supported by the Web Authentication API.\n U2F is Chrome's original security key API. It allows sites to register public key credentials on USB security keys and challenge them for building phishing-resistant two-factor authentication systems. U2F never became an open web standard and was subsumed by the Web Authentication API (launched in Chrome 67). Chrome never directly supported the FIDO U2F JavaScript API, but rather shipped a component extension called cryptotoken, which exposes an equivalent chrome.runtime.sendMessage() method. U2F and Cryptotoken are firmly in maintenance mode and have encouraged sites to migrate to the Web Authentication API for the last two years.\n The following timeline is currently planned for deprecation and removal:\n Chrome 93\nStable as of August 31, 2021. Support added for the googleLegacyAppIdSupport extension.\n Chrome 95\nBeta as of September 23, 2021. The following changes were implemented:\n\nGated U2F API requests behind a user permission prompt.\nLogged a deprecation notice in the DevTools console for every request.\n \nChrome 98\nBeta expected in early January 2022, stable in February. The deprecation trial will continue, but its behavior will reverse: the API will be disabled by default, but may be kept alive by trial participants.\n Chrome 103\nBeta expected in late May 2022, stable in late June. The deprecation trial will end.\nChrome 104\nBeta expected in late June 2022, stable in early August. The  U2F API will be fully removed.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-5118443679325405951",
        "isoDate": "2021-09-23T23:37:00.003Z"
    },
    {
        "title": "User-Agent Reduction Origin Trial and Dates",
        "link": "http://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-dates.html",
        "pubDate": "2021-09-14T13:26:00.001Z",
        "author": "Chromium Blog",
        "content": "<p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Back in May, we published </span><a href=\"https://blog.chromium.org/2021/05/update-on-user-agent-string-reduction.html\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">an update on our User-Agent string reduction plans</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> with a promise to publish further details on timing. Now that we have an </span><a href=\"http://developers.chrome.com/blog/user-agent-reduction-origin-trial\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">origin trial ready for testing</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> the Reduced User-Agent header (and associated JS interfaces) we have estimated timelines to share. What follows is repeated from the original blog post, but contains estimated Chrome versions where these Phases will begin to help you prepare.&nbsp;</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">The </span><a href=\"https://chromiumdash.appspot.com/schedule\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">Chromium schedule dashboard</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> will be useful for understanding dates associated with each Chrome version and its progression from Canary into Beta and Stable Release.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Note: The usual disclaimers about estimating engineering deadlines apply—unforeseen circumstances may dictate delays. But in the case that we encounter delays, we do not intend to accelerate timelines between Phases.</span></p><br /><h3 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;\"><span style=\"color: #434343; font-family: Arial; font-size: 14pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;\">Proposed Rollout Plan</span></h3><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">We plan to roll out these changes slowly and incrementally in 7 Phases—pending origin trial feedback.</span></p><br /><h4 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 14pt;\"><span style=\"color: #666666; font-family: Arial; font-size: 12pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;\">Reduction Preparation</span></h4><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 1: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Since Chrome 92 (July 20, 2021)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Call to Action (CTA): </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Audit your site usage to understand where migration may be necessary.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Warn about accessing </span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.userAgent</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">, </span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.appVersion</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">, and </span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.platform</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> in DevTools, beginning in M92.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 2: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 95 to Chrome 100</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">CTA: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Enroll in the <span style=\"font-size: 14.6667px;\">origin trial</span> for your site, and provide feedback until Chrome 101 is released.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Launch an <span style=\"font-size: 14.6667px;\">origin trial</span> for sites to opt into the final reduced UA string for testing and feedback, for at least 6 months.&nbsp;</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">We will evaluate feedback from <span style=\"font-size: 14.6667px;\">origin trial</span> partners and the community, and based on this feedback proceed to Phases 3 through 7 of our plan, giving the ecosystem adequate time to adapt in between them. Otherwise, depending on feedback we will reconsider the best course of action.</span></p><br /><h4 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 14pt;\"><span style=\"color: #666666; font-family: Arial; font-size: 12pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;\">Reduction Rollout</span></h4><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 3: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 100</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">CTA: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Enroll in the deprecation trial or Enterprise policy for your site, when needed.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Launch deprecation trial and Enterprise policy, for instances where a site may need more time for migration.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 4: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 101</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">CTA: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Ensure your site is compatible with the reduced Chrome version number, and </span><a href=\"https://web.dev/migrate-to-ua-ch/\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">migrate to UA Client Hints</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> if not.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Ship reduced Chrome MINOR.BUILD.PATCH version numbers (“0.0.0”). Once rolled-out, the reduced UA string would apply to all page loads on desktop and mobile operating systems for sites that do not opt into the deprecation trial.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 5: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 107</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">CTA: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Ensure your site is compatible with the reduced Desktop UA string and related JS APIs, and </span><a href=\"https://web.dev/migrate-to-ua-ch/\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">migrate to UA Client Hints</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> if not.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Begin roll-out of reduced Desktop UA string and related JS APIs (</span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.userAgent</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">, </span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.appVersion</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">, </span><span style=\"font-family: courier; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">navigator.platform</span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">). Once rolled-out, the reduced UA string would apply to all page loads on desktop <span style=\"font-size: 14.6667px;\">operating systems</span> for sites that do not opt into the <span style=\"font-size: 14.6667px;\">deprecation trial</span>.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 6: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 110</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">CTA: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Ensure your site is compatible with the reduced Mobile UA string and related JS APIs, and </span><a href=\"https://web.dev/migrate-to-ua-ch/\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">migrate to UA Client Hints</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> if not.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Begin roll-out of reduced Android Mobile (and Tablet) UA string and related JS APIs. Once rolled-out, the reduced UA string would apply to all page loads on Android that do not opt into the <span style=\"font-size: 14.6667px;\">deprecation trial</span>.</span></p><br /><h4 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 14pt;\"><span style=\"color: #666666; font-family: Arial; font-size: 12pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 400; vertical-align: baseline; white-space: pre-wrap;\">Reduction Completion</span></h4><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Phase 7: </span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">Chrome 113</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Deprecation trial ends and all page loads receive the reduced UA string and related JS APIs.</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">See the companion </span><a href=\"https://www.chromium.org/updates/ua-reduction\" style=\"text-decoration-line: none;\"><span style=\"color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;\">Reduced User Agent string updates page</span></a><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> for more details and example User Agent strings at each of these phases. We will note any significant delays or changes on this page as well.</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"></span></p><div class=\"post-body\" style=\"color: rgba(0, 0, 0, 0.87); font-family: Roboto, sans-serif; font-size: 14px; width: 660px;\"><div class=\"post-content post-original\" itemprop=\"articleBody\" style=\"font-size: 17px; line-height: 32px; margin: 25px 0px 36px;\"><span class=\"post-author\" color=\"rgba(0, 0, 0, 0.54)\" style=\"font-size: 14px;\">Posted by Mike Taylor and Jade Kessler, Chrome Team</span></div></div>",
        "contentSnippet": "Back in May, we published an update on our User-Agent string reduction plans with a promise to publish further details on timing. Now that we have an origin trial ready for testing the Reduced User-Agent header (and associated JS interfaces) we have estimated timelines to share. What follows is repeated from the original blog post, but contains estimated Chrome versions where these Phases will begin to help you prepare. \n\nThe Chromium schedule dashboard will be useful for understanding dates associated with each Chrome version and its progression from Canary into Beta and Stable Release.\n\nNote: The usual disclaimers about estimating engineering deadlines apply—unforeseen circumstances may dictate delays. But in the case that we encounter delays, we do not intend to accelerate timelines between Phases.\n\nProposed Rollout Plan\nWe plan to roll out these changes slowly and incrementally in 7 Phases—pending origin trial feedback.\n\nReduction Preparation\nPhase 1: Since Chrome 92 (July 20, 2021)\nCall to Action (CTA): Audit your site usage to understand where migration may be necessary.\n\nWarn about accessing navigator.userAgent, navigator.appVersion, and navigator.platform in DevTools, beginning in M92.\n\nPhase 2: Chrome 95 to Chrome 100\nCTA: Enroll in the origin trial for your site, and provide feedback until Chrome 101 is released.\n\nLaunch an origin trial for sites to opt into the final reduced UA string for testing and feedback, for at least 6 months. \n\nWe will evaluate feedback from origin trial partners and the community, and based on this feedback proceed to Phases 3 through 7 of our plan, giving the ecosystem adequate time to adapt in between them. Otherwise, depending on feedback we will reconsider the best course of action.\n\nReduction Rollout\nPhase 3: Chrome 100\nCTA: Enroll in the deprecation trial or Enterprise policy for your site, when needed.\n\nLaunch deprecation trial and Enterprise policy, for instances where a site may need more time for migration.\n\nPhase 4: Chrome 101\nCTA: Ensure your site is compatible with the reduced Chrome version number, and migrate to UA Client Hints if not.\n\nShip reduced Chrome MINOR.BUILD.PATCH version numbers (“0.0.0”). Once rolled-out, the reduced UA string would apply to all page loads on desktop and mobile operating systems for sites that do not opt into the deprecation trial.\n\nPhase 5: Chrome 107\nCTA: Ensure your site is compatible with the reduced Desktop UA string and related JS APIs, and migrate to UA Client Hints if not.\n\nBegin roll-out of reduced Desktop UA string and related JS APIs (navigator.userAgent, navigator.appVersion, navigator.platform). Once rolled-out, the reduced UA string would apply to all page loads on desktop operating systems for sites that do not opt into the deprecation trial.\n\nPhase 6: Chrome 110\nCTA: Ensure your site is compatible with the reduced Mobile UA string and related JS APIs, and migrate to UA Client Hints if not.\n\nBegin roll-out of reduced Android Mobile (and Tablet) UA string and related JS APIs. Once rolled-out, the reduced UA string would apply to all page loads on Android that do not opt into the deprecation trial.\n\nReduction Completion\nPhase 7: Chrome 113\n\nDeprecation trial ends and all page loads receive the reduced UA string and related JS APIs.\n\nSee the companion Reduced User Agent string updates page for more details and example User Agent strings at each of these phases. We will note any significant delays or changes on this page as well.\n\n\nPosted by Mike Taylor and Jade Kessler, Chrome Team",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-6157306198116036384",
        "isoDate": "2021-09-14T13:26:00.001Z"
    },
    {
        "title": "Chrome 94 Beta: WebCodecs, WebGPU, Scheduling, and More",
        "link": "http://blog.chromium.org/2021/08/chrome-94-beta-webcodecs-webgpu.html",
        "pubDate": "2021-08-26T19:06:00.000Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D76\">ChromeStatus.com</a>. Chrome 94 is beta as of August 26, 2021.</p> <h2>WebCodecs</h2><p>Existing media APIs (<code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement\">HTMLMediaElement</a></code>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\">Media Source Extensions</a>, <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\">WebAudio</a></code>, <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder\">MediaRecorder</a></code>, and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\">WebRTC</a>) are high-level and narrowly-focused. A low-level codec API would better support emerging applications, such as latency-sensitive game streaming, client-side effects or transcoding, and polyfillable media container support, without the increased network and CPU cost of JavaScript or WebAssembly codec implementations. </p> <p>The WebCodecs API eliminates these deficiencies by giving programmers a way to use media components that are already present in the browser. Specifically:<br /></p><ul><li>Video and audio decoders</li><li>Video and audio encoders</li><li>Raw video frames</li><li>Image decoders</li></ul> <p>This feature has also completed its origin trial in Chrome 93 and is now available by default. For more information, see <a href=\"https://web.dev/webcodecs/\">Video processing with WebCodecs</a>. </p> <h2>WebGPU</h2><p>The WebGPU API is the successor to the WebGL and WebGL2 graphics APIs for the Web. It provides modern features such as \"GPU compute\" as well as lower overhead access to GPU hardware and better, more predictable performance. This is an improvement over the existing WebGL interfaces, which were designed for drawing images but could only be repurposed for other kinds of computations with great effort.</p> <p>WebGPU exposes modern computer graphics capabilities, specifically Direct3D 12, Metal, and Vulkan, for performing rendering and computation operations on a graphics processing unit (GPU). Advantages of WebGPU over earlier technologies include:</p> <ul><li>Separating resource management, work preparation, and submission to the GPU.</li><li>Pipeline states that function similarly to OS APIs.</li><li>Binding groups that allow graphics drivers to perform needed preparations in advance of rendering.</li></ul> <p>This feature is starting an origin trial in Chrome 94 with the hope of shipping in Chrome 99. For more information, see <a href=\"https://web.dev/gpu/\">Access modern GPU features with WebGPU</a>.</p> <h2>Scheduling APIs: Prioritized scheduler.postTask()</h2><p>It's difficult to build web apps that are responsive to user interaction and that remain responsive over time. Scripts are one of the primary culprits hurting responsiveness. Consider a \"search-as-you-type\" feature: an app with this capability needs to keep up with the user's typing at the same time that it is fetching and displaying results. This doesn't take into account anything happening on the page such as animation, which must be rendered smoothly.</p> <p>The problem is usually tackled by chunking and scheduling main thread work, specifically executing work asynchronously at appropriate times. This approach has its own problems, including the fact that whatever priority the developer sets, it's still competing for time on the main thread, which doesn't recognize the developer's prioritization, and is also responsible for browser tasks such as <code>fetch()</code> operations and garbage collection. </p> <p>The <a href=\"https://www.chromestatus.com/feature/6031161734201344\"><code>scheduler.postTask()</code> method</a> fixes these scheduling dilemmas by letting developers schedule tasks (JavaScript callbacks) with an OS browser scheduler at three levels of priority: user-blocking, user-visible, and background. It also exposes a <code>TaskController</code> interface, which can dynamically cancel tasks and change their priority. </p> <p>This feature completed its origin trial in Chrome 93 and is now available by default in Chrome. For a list of other new and completed origin trials, see the Origin Trials section below.</p> <h2>Origin Trials</h2><p>In addition to the items above, this version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h3>New Origin Trials</h3> <h4>Early Hints for Navigation</h4><p>Chrome is testing <a href=\"https://developer.chrome.com/origintrials/#/view_trial/2856408063659737089\">a new HTTP status code</a>: 103 Early Hints for preloading subresources earlier. <br />When a 103 response includes <code>&lt;link rel=preload&gt;</code> or other link headers Chromium tries to preload (and/or preconnect, prefetch) specified resources before the final response is received. This gives web developers a way to optimize apps, sites, and pages.</p> <h3>Completed Origin Trials</h3><p>The following features, previously in a Chrome origin trial, are now enabled by default.</p> <h4>Canvas Color Management</h4><p>This update <a href=\"https://www.chromestatus.com/feature/5807007661555712\">formalizes that the default color space</a> for <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\">CanvasRenderingContext2D</a></code> objects and <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ImageData\">ImageData</a></code> objects is sRGB. This clarifies that the <code>CanvasRenderingContext2D</code> interface is fully color managed (that all inputs are converted to the canvas color space). These were previously conventions and not clearly specified. This updates makes the following changes:</p> <ul><li>Adds parameters to specify a non-sRGB color space when creating a <code>CanvasRenderingContext2D</code> object or an <code>ImageData</code> object.</li><li>Adds support for the Display P3 color space for these parameters.</li></ul> <p>Content displayed by <code>CanvasRenderingContext2D</code> is currently limited to the sRGB color space, which is less than the capabilities of modern displays and cameras. This feature allows creating a <code>CanvasRenderingContext2D</code> object that is in the Display P3 color space. This also clears up several points of ambiguity about the color behavior of <code>CanvasRenderingContext2D</code>.</p> <h4>VirtualKeyboard API</h4><p>The <code>VirtualKeyboard</code> interface has methods and properties to <a href=\"https://www.chromestatus.com/feature/5680057076940800\">control when a virtual keyboard is shown or hidden</a>. It also fires events with the size of the virtual keyboard when it occludes content in the page. The virtual keyboard is the on-screen keyboard used for input in scenarios where a hardware keyboard may not be available. </p> <p>Unlike a hardware keyboard, a virtual keyboard can adapt its shape to optimize for the expected input. Developers have control over the displayed shape of the virtual keyboard through the <code>inputmode</code> attribute, but have limited control over when the virtual keyboard is shown or hidden.</p> <h2>Other features in this release</h2> <h3>CSS</h3> <h4>Align transform-style: preserve-3d and perspective Property with the Spec</h4><p><a href=\"https://www.chromestatus.com/feature/5640541339385856\">The transform-style: preserve-3d and perspective properties now align with the spec</a>. The preserve-3d property allows child elements to participate in the parent's 3D scene, and the perspective property applies a perspective transform to child elements. Before this change, Chromium applied both of these effects based on the containing block hierarchy rather than the DOM tree, and allowed them to extend through elements without transform-related properties on them.</p> <h4>flex-basis Honors Keywords 'content' and 'min/max/fit-content'</h4><p><a href=\"https://www.chromestatus.com/feature/5635933158244352\">Chrome now supports</a> the keywords <code>content</code>, <code>min-content</code>, <code>max-content</code>, and <code>fit-content</code> as values for the <code>flex-basis</code> property and its <code>flex</code> shorthand. The <code>content</code> keyword makes flex base size use the default sizing rules as if <code>flex-basis</code> and preferred size property (<code>width</code> or <code>height</code>) are both <code>auto</code>, ignoring any specified <code>width</code> or <code>height</code> in the main axis dimension when <code>flex-basis</code> is <code>auto</code>. The other keywords are the same as usual and give more options for specifying the flex base size.</p> <p>In responsive layouts, when adding or removing <code>display:flex</code> to a container, you previously had to sometimes add/remove values for each individual item. <code>content</code> eliminates the need in some situations.</p> <h4>scrollbar-gutter</h4><p>The <a href=\"https://www.chromestatus.com/feature/5746559209701376\"><code>scrollbar-gutter</code> property</a> provides control over the presence of scrollbar gutters (the space reserved to display a scrollbar), allowing developers to prevent layout changes as content expands while avoiding unwanted visuals when scrolling isn't needed.<br /><br />Note that the presence of the scrollbars themselves is determined by the <code>overflow</code> property. The choice of classical or overlay scrollbars is up to the user agent. This property provides developers with more control over how their layouts interact with the scrollbars provided by the browser.</p> <h3>MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)</h3><p>This API lets developers <a href=\"https://web.dev/mediastreamtrack-insertable-media-processing/\">manipulate raw media carried by <code>MediaStreamTracks</code></a> such as the output of cameras, microphones, screen captures or the decoder part of a codec and the input to the decoder part of a codec. It uses WebCodecs interfaces to represent raw media frames and exposes them using streams, similar to the way the WebRTC Insertable Streams exposes encoded data from <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection\">RTCPeerConnections</a>. Example use cases include <a href=\"https://www.w3.org/TR/webrtc-nv-use-cases/#funnyhats*\">funny hats</a> and <a href=\"https://www.w3.org/TR/webrtc-nv-use-cases/#machinelearning*\">real-time object identification and annotation</a>.</p> <h3>Return Fixed Lists for navigator.plugins and navigator.mimeTypes</h3><p>With the removal of Flash, there is no longer a need to return anything for <code>navigator.plugins</code> and <code>navigator.mimeTypes</code>. These APIs were used primarily for:</p> <ul> <li>Probing for Flash player support</li> <li>Fingerprinting. </li> </ul> <p>Some sites use these APIs to probe for PDF viewer support. With this change, <a href=\"https://www.chromestatus.com/feature/5741884322349056\">these arrays will return fixed lists</a> containing a standard list of PDF viewer plugins.</p> <p>Note that this is not the removal or change of any API, it is merely the return of fixed arrays for these two existing APIs.</p> <h2>JavaScript</h2><p>This version of Chrome incorporates version 9.4 of the V8 JavaScript engine. It specifically includes the change listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h3>Self Profiling API</h3><p>Chrome now supports <a href=\"https://www.chromestatus.com/feature/5170190448852992\">a web-exposed sampling profiler</a> for measuring client JavaScript execution time. Gathering JavaScript profiles from real users can help developers debug slow observed performance without invasive manual instrumentation.</p> <h2>Deprecations, and Removals</h2><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h3>Deprecate and Remove WebSQL in Third-Party Contexts</h3><p><a href=\"https://www.chromestatus.com/feature/5684870116278272\">WebSQL in third-party contexts is now deprecated</a>. Removal is expected in Chrome 97. The Web SQL Database standard was first proposed in April 2009 and abandoned in November 2010. Gecko never implemented this feature and WebKit deprecated in in 2019. The W3C encourages <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\">Web Storage</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\">Indexed Database</a> for those needing alternatives.</p> <p>Developers should expect that WebSQL itself will be deprecated and removed when usage is low enough.</p> <h3>Restrict Private Network Requests for Subresources to Secure Contexts</h3><p>Private network requests for subresources <a href=\"https://developer.chrome.com/blog/private-network-access-update/\">may now only be initiated from a secure context</a>. Private network requests are those initiated from a public network, targeting a private network. Examples include internet to <em>intranet</em> requests and intranet loopbacks. </p> <p>This is a first step towards fully implementing <a href=\"https://wicg.github.io/private-network-access/\">Private Network Access</a>. Servers running inside local networks, or on a user's device, expose powerful capabilities to the web in ways that can be quite dangerous. Private Network Access proposes a set of changes to limit the impact of requests to these servers by ensuring that the servers are opting-into any communication with external entities.</p> <p>For this opt-in to have any meaning, the servers need to be able to ensure that the client origin is authenticated. To that end, only secure contexts are empowered to make external requests.</p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 94 is beta as of August 26, 2021.\n WebCodecs\nExisting media APIs (HTMLMediaElement, Media Source Extensions, WebAudio, MediaRecorder, and WebRTC) are high-level and narrowly-focused. A low-level codec API would better support emerging applications, such as latency-sensitive game streaming, client-side effects or transcoding, and polyfillable media container support, without the increased network and CPU cost of JavaScript or WebAssembly codec implementations. \n The WebCodecs API eliminates these deficiencies by giving programmers a way to use media components that are already present in the browser. Specifically:\n\nVideo and audio decoders\nVideo and audio encoders\nRaw video frames\nImage decoders\n \nThis feature has also completed its origin trial in Chrome 93 and is now available by default. For more information, see Video processing with WebCodecs. \n WebGPU\nThe WebGPU API is the successor to the WebGL and WebGL2 graphics APIs for the Web. It provides modern features such as \"GPU compute\" as well as lower overhead access to GPU hardware and better, more predictable performance. This is an improvement over the existing WebGL interfaces, which were designed for drawing images but could only be repurposed for other kinds of computations with great effort.\n WebGPU exposes modern computer graphics capabilities, specifically Direct3D 12, Metal, and Vulkan, for performing rendering and computation operations on a graphics processing unit (GPU). Advantages of WebGPU over earlier technologies include:\n \nSeparating resource management, work preparation, and submission to the GPU.\nPipeline states that function similarly to OS APIs.\nBinding groups that allow graphics drivers to perform needed preparations in advance of rendering.\n \nThis feature is starting an origin trial in Chrome 94 with the hope of shipping in Chrome 99. For more information, see Access modern GPU features with WebGPU.\n Scheduling APIs: Prioritized scheduler.postTask()\nIt's difficult to build web apps that are responsive to user interaction and that remain responsive over time. Scripts are one of the primary culprits hurting responsiveness. Consider a \"search-as-you-type\" feature: an app with this capability needs to keep up with the user's typing at the same time that it is fetching and displaying results. This doesn't take into account anything happening on the page such as animation, which must be rendered smoothly.\n The problem is usually tackled by chunking and scheduling main thread work, specifically executing work asynchronously at appropriate times. This approach has its own problems, including the fact that whatever priority the developer sets, it's still competing for time on the main thread, which doesn't recognize the developer's prioritization, and is also responsible for browser tasks such as fetch() operations and garbage collection. \n The scheduler.postTask() method fixes these scheduling dilemmas by letting developers schedule tasks (JavaScript callbacks) with an OS browser scheduler at three levels of priority: user-blocking, user-visible, and background. It also exposes a TaskController interface, which can dynamically cancel tasks and change their priority. \n This feature completed its origin trial in Chrome 93 and is now available by default in Chrome. For a list of other new and completed origin trials, see the Origin Trials section below.\n Origin Trials\nIn addition to the items above, this version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n Early Hints for Navigation\nChrome is testing a new HTTP status code: 103 Early Hints for preloading subresources earlier. \nWhen a 103 response includes <link rel=preload> or other link headers Chromium tries to preload (and/or preconnect, prefetch) specified resources before the final response is received. This gives web developers a way to optimize apps, sites, and pages.\n Completed Origin Trials\nThe following features, previously in a Chrome origin trial, are now enabled by default.\n Canvas Color Management\nThis update formalizes that the default color space for CanvasRenderingContext2D objects and ImageData objects is sRGB. This clarifies that the CanvasRenderingContext2D interface is fully color managed (that all inputs are converted to the canvas color space). These were previously conventions and not clearly specified. This updates makes the following changes:\n \nAdds parameters to specify a non-sRGB color space when creating a CanvasRenderingContext2D object or an ImageData object.\nAdds support for the Display P3 color space for these parameters.\n \nContent displayed by CanvasRenderingContext2D is currently limited to the sRGB color space, which is less than the capabilities of modern displays and cameras. This feature allows creating a CanvasRenderingContext2D object that is in the Display P3 color space. This also clears up several points of ambiguity about the color behavior of CanvasRenderingContext2D.\n VirtualKeyboard API\nThe VirtualKeyboard interface has methods and properties to control when a virtual keyboard is shown or hidden. It also fires events with the size of the virtual keyboard when it occludes content in the page. The virtual keyboard is the on-screen keyboard used for input in scenarios where a hardware keyboard may not be available. \n Unlike a hardware keyboard, a virtual keyboard can adapt its shape to optimize for the expected input. Developers have control over the displayed shape of the virtual keyboard through the inputmode attribute, but have limited control over when the virtual keyboard is shown or hidden.\n Other features in this release\n CSS\n Align transform-style: preserve-3d and perspective Property with the Spec\nThe transform-style: preserve-3d and perspective properties now align with the spec. The preserve-3d property allows child elements to participate in the parent's 3D scene, and the perspective property applies a perspective transform to child elements. Before this change, Chromium applied both of these effects based on the containing block hierarchy rather than the DOM tree, and allowed them to extend through elements without transform-related properties on them.\n flex-basis Honors Keywords 'content' and 'min/max/fit-content'\nChrome now supports the keywords content, min-content, max-content, and fit-content as values for the flex-basis property and its flex shorthand. The content keyword makes flex base size use the default sizing rules as if flex-basis and preferred size property (width or height) are both auto, ignoring any specified width or height in the main axis dimension when flex-basis is auto. The other keywords are the same as usual and give more options for specifying the flex base size.\n In responsive layouts, when adding or removing display:flex to a container, you previously had to sometimes add/remove values for each individual item. content eliminates the need in some situations.\n scrollbar-gutter\nThe scrollbar-gutter property provides control over the presence of scrollbar gutters (the space reserved to display a scrollbar), allowing developers to prevent layout changes as content expands while avoiding unwanted visuals when scrolling isn't needed.\nNote that the presence of the scrollbars themselves is determined by the overflow property. The choice of classical or overlay scrollbars is up to the user agent. This property provides developers with more control over how their layouts interact with the scrollbars provided by the browser.\n MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)\nThis API lets developers manipulate raw media carried by MediaStreamTracks such as the output of cameras, microphones, screen captures or the decoder part of a codec and the input to the decoder part of a codec. It uses WebCodecs interfaces to represent raw media frames and exposes them using streams, similar to the way the WebRTC Insertable Streams exposes encoded data from RTCPeerConnections. Example use cases include funny hats and real-time object identification and annotation.\n Return Fixed Lists for navigator.plugins and navigator.mimeTypes\nWith the removal of Flash, there is no longer a need to return anything for navigator.plugins and navigator.mimeTypes. These APIs were used primarily for:\n  \nProbing for Flash player support\n Fingerprinting. \n  \nSome sites use these APIs to probe for PDF viewer support. With this change, these arrays will return fixed lists containing a standard list of PDF viewer plugins.\n Note that this is not the removal or change of any API, it is merely the return of fixed arrays for these two existing APIs.\n JavaScript\nThis version of Chrome incorporates version 9.4 of the V8 JavaScript engine. It specifically includes the change listed below. You can find a complete list of recent features in the V8 release notes.\n Self Profiling API\nChrome now supports a web-exposed sampling profiler for measuring client JavaScript execution time. Gathering JavaScript profiles from real users can help developers debug slow observed performance without invasive manual instrumentation.\n Deprecations, and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n Deprecate and Remove WebSQL in Third-Party Contexts\nWebSQL in third-party contexts is now deprecated. Removal is expected in Chrome 97. The Web SQL Database standard was first proposed in April 2009 and abandoned in November 2010. Gecko never implemented this feature and WebKit deprecated in in 2019. The W3C encourages Web Storage and Indexed Database for those needing alternatives.\n Developers should expect that WebSQL itself will be deprecated and removed when usage is low enough.\n Restrict Private Network Requests for Subresources to Secure Contexts\nPrivate network requests for subresources may now only be initiated from a secure context. Private network requests are those initiated from a public network, targeting a private network. Examples include internet to intranet requests and intranet loopbacks. \n This is a first step towards fully implementing Private Network Access. Servers running inside local networks, or on a user's device, expose powerful capabilities to the web in ways that can be quite dangerous. Private Network Access proposes a set of changes to limit the impact of requests to these servers by ensuring that the servers are opting-into any communication with external entities.\n For this opt-in to have any meaning, the servers need to be able to ensure that the client origin is authenticated. To that end, only secure contexts are empowered to make external requests.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-1101366622128981256",
        "isoDate": "2021-08-26T19:06:00.000Z"
    },
    {
        "title": "Chrome 93: Multi-Screen Window Placement, PWAs as URL Handlers, and More",
        "link": "http://blog.chromium.org/2021/07/chrome-93-multi-screen-window-placement.html",
        "pubDate": "2021-07-29T19:00:00.007Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Android WebView, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D76\">ChromeStatus.com</a>. Chrome 93 is beta as of July 29, 2021.</p> <h2>Origin Trials</h2><p>This version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h3>New Origin Trials</h3> <h4>Cross-Origin-Embedder-Policy: credentialless</h4><p>Cross-origin no-CORS requests <a href=\"https://developer.chrome.com/origintrials/#/view_trial/3036552048754556929\">can now be made to omit credentials</a> (cookies, client certificates, etc.) using the <code>credentialless</code> keyword. Similarly to <code>COEP: require-corp</code>, it can enable cross-origin isolation.</p> <p>Sites that wish to continue using <code>SharedArrayBuffer</code> must opt-in to cross-origin isolation. Today, <code>COEP: require-corp</code> exists, and is used to enable cross-origin isolation. It is functional and solid, but turns out to be difficult to deploy at scale, as it requires all subresources to explicitly opt-in. This is fine for some sites, but creates dependency problems for sites that gather content from users (Google Earth, social media generally, forums, etc.).</p> <h4>Multi-Screen Window Placement</h4><p>The <a href=\"https://web.dev/multi-screen-window-placement/\">Multi-Screen Window Placement API</a> allows you to place windows on any display connected to your machine, store that placement, and make a window full-screen on any display. With this API, a presentation app can show slides on one screen and speaker notes on another. An art or music creation app can place palettes on a second screen. And a restaurant can show a touchscreen menu on a kiosk and a separate window for employees. Incorporating developer feedback from the first origin trial, the API enters a second origin trial with an improved shape and ergonomics.</p> <h4>Window Controls Overlay for Installed Desktop Web Apps</h4><p>Window controls overlay extends an app's client area to cover the entire window, including the title bar, and the window control buttons (close, maximize/restore, minimize). The web app developer is responsible for drawing and input-handling for the entire window except for the window controls overlay. Developers can use this feature to make their installed desktop web apps look like O.S. apps. For more information, see <a href=\"https://web.dev/window-controls-overlay/\">Customize the window controls overlay of your PWA's title bar</a>.</p> <h4>PWAs as URL Handlers</h4><p><a href=\"https://web.dev/pwa-url-handler/\">PWA as URL Handlers</a> allows apps like <code>music.example.com</code> to register themselves as URL handlers for URLs that match patterns like <code>https://music.example.com</code>, <code>https://*.music.example.com</code>, or <code>https://🎵.example.com</code>, so that links from outside of the PWA, for example, from an instant messenger application or an email client, open in the installed PWA rather than in a browser tab.</p> <h3>Completed Origin Trials</h3><p>The following features, previously in a Chrome origin trial, are now enabled by default.</p> <h4>Subresource loading with Web Bundles</h4><p><a href=\"https://www.chromestatus.com/feature/5710618575241216\">Web Bundles</a> provides a new approach to load a large number of resources efficiently using a format that allows multiple resources to be bundled. This feature addresses issues with previous approaches to resource bundling. </p> <p>The output of some JavaScript bundlers does not interact well with the HTTP cache and configuring them can sometimes be difficult. Even with bundled JavaScript, execution needs to wait for all bytes to download. Ideally loading multiple subresources should use streaming and parallelization, which is not possible with one JavaScript file. For JavaScript modules, execution still needs to wait for an entire resource tree to download because of deterministic execution.</p> <h4>WebXR Plane Detection API</h4><p>WebXR applications can now <a href=\"https://www.chromestatus.com/feature/5732397976911872\">retrieve data about planes present in a user's environment</a>, which enables augmented reality applications to create more immersive experiences. Without this feature, developers would have to resort to running their own computer vision algorithms on data from <code>getUserMedia()</code> (available on <code>navigator</code> and <code>MediaDevices</code>) in order to detect planes present in the users' environment. Such solutions have thus far been unable to match the quality and accuracy of native augmented reality capabilities or support world scale.</p> <h2>Other features in this release</h2> <h4>AbortSignal.abort() Static Method</h4><p><a href=\"https://www.chromestatus.com/feature/5642501387976704\"><code>AbortSignal.abort()</code> is a static method</a> that allows creating a new <code>AbortSignal</code> object that is already aborted. It is similar in spirit to <code>Promise.reject()</code>, and provides improved developer ergonomics.</p> <p>Web developers have found aborted <code>AbortSignal</code> objects to be useful for a variety of purposes. They signify to JavaScript APIs that no work should be done. Currently, creating an already-aborted <code>AbortSignal</code> object requires multiple lines of code. <code>AbortSignal.abort()</code> requires one:<br /><br /><code>return AbortSignal.abort();</code></p> <h4>CSS Flexbox: Support Alignment Keywords start, end, self-start, self-end, left, right</h4><p>The flexbox and flex items <a href=\"https://www.chromestatus.com/feature/5777880099323904\">now obey</a> <a href=\"https://drafts.csswg.org/css-align-3/#positional-values\">positional alignment keywords</a>. Flexbox previously only obeyed <code>center</code>, <code>flex-start</code>, and <code>flex-end</code>. The additional alignment keywords (<code>start</code>, <code>end</code>, <code>self-start</code>, <code>self-end</code>, <code>left</code>, <code>right</code>) allow authors to more easily align the flex items in the face of varying writing modes and flex flows.</p> <p>Without these additional keywords, developers need to change the keyword values whenever they change the writing mode, text direction, or flex reversal properties (<code>flex-direction: row-reverse</code>, <code>flex-direction:column-reverse</code> or <code>align-content: wrap-reverse</code>). The keywords implemented here let them set alignment once.</p> <h4>Error.cause Property</h4><p>The <code>Error()</code> constructor supports <a href=\"https://www.chromestatus.com/feature/5727099325251584\">a new options property called cause</a>, which will be assigned to the error as a property. This allows errors to be chained without unnecessary and overelaborate formalities on wrapping the errors in conditions.</p> <h4>Honor Media HTML Attribute for meta name=theme-color</h4><p><a href=\"https://www.chromestatus.com/feature/5764461413531648\">The meta element's \"media\" attribute will be honored</a> for <code>meta[name=\"theme-color\"]</code> so that web developers can adjust the <a href=\"https://web.dev/add-manifest/#theme-color\">theme color</a> of their site based on a media query (dark and light modes for instance). The first one that matches will be picked.</p> <h4>noplaybackrate in HTMLMediaElement.controlsList </h4><p>The <a href=\"https://www.chromestatus.com/feature/5092414224072704\">HTMLMediaElement.controlsList property now supports <code>noplaybackrate</code></a>, which allows websites to enabled or disable the playback speed control exposed by the browser. With browser vendors adding playback speed control to their media controls, developers should have a way to control the visibility of this new control. Try the new property on the <a href=\"https://googlechrome.github.io/samples/media/controlslist-noplaybackrate.html\"><code>noplaybackrate</code> in <code>HTMLMediaElement.controlsList</code> Sample</a>.</p> <h4>Sec-CH-Prefers-Color-Scheme Client Hint Header</h4><p>The CSS user preference media feature <a href=\"https://web.dev/prefers-color-scheme/\"><code>prefers-color-scheme</code></a> has a potentially significant impact on the amount of CSS that needs to be delivered by a page and on the experience the user is going to have when the page loads. The new <a href=\"https://github.com/WICG/user-preference-media-features-headers#demo-of-sec-ch-prefers-color-scheme\"><code>Sec-CH-Prefers-Color-Scheme</code></a> client hint header allows sites to obtain the user's preference optionally at request time, allowing servers to inline the right CSS and therefore avoid a flash of incorrect color theme.</p><h4 style=\"text-align: left;\">User-Agent Client Hints API Updates</h4><p>This version of Chrome adds <a href=\"https://www.chromestatus.com/feature/5733498725859328\">four new features and changes</a> to the User-Agent client hints API.</p> <ul><li><strong>Sec-CH-UA-Bitness:</strong> a request header that gives a server information about the bitness of the architecture of the platform on which a given user agent is executing. Bitness is the number of bits comprising the basic value a particular system can evaluate.<br /></li><li><strong>Make Sec-CH-UA-Platform a low-entropy hint: </strong><code>Sec-CH-UA-Platform</code> is a request header that gives a server information about the platform on which a given user agent is executing.<br /></li><li><strong>Adds low-entropy hints to UADataValues.getHighEntropyValues():</strong> If a hint moves from high to low-entropy, this future proofs any code relying on it.</li></ul> <ul><li><strong>Improves</strong> <strong>NavigatorUAData.toJSON() method:</strong> This method now returns useful data.</li></ul> <p>Low-entropy hints are those that don't give away too much information, or give information that would be too easy to discover in other ways to realistically hide. In the context of client hints, this means that these hints are available in every request, whether or not the origin involved requested it or whether the frame involved is a first or third party context.</p> <h4>WebOTP API: Cross-Device Support</h4><p><a href=\"https://developer.chrome.com/blog/cross-device-webotp/\">The WebOTP API will now be supported on desktop</a> when both Chrome on Desktop and Android Chrome are logged in using the same Google account. The WebOPT API provides the ability to programmatically read a one-time code from specially-formatted SMS messages addressed to their origin, reducing user friction during sign-on. Previously, this was only available on mobile devices where SMS was supported.</p> <div class=\"separator\" style=\"clear: both;\"><a href=\"https://1.bp.blogspot.com/-iVMXuQ7BS-U/YQQEj7I-rgI/AAAAAAAABow/OchREkcfsMku8AexLegD2UEmZamTABL7gCLcBGAsYHQ/s800/x-device-webotp.gif\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"525\" data-original-width=\"800\" height=\"420\" src=\"https://1.bp.blogspot.com/-iVMXuQ7BS-U/YQQEj7I-rgI/AAAAAAAABow/OchREkcfsMku8AexLegD2UEmZamTABL7gCLcBGAsYHQ/w640-h420/x-device-webotp.gif\" width=\"640\" /></a></div> <h2>JavaScript</h2><p>This version of Chrome incorporates version 9.3 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h4>Object.hasOwn</h4><p><a href=\"https://www.chromestatus.com/feature/5662263404920832\"><code>Object.hasOwn</code></a>, a new boolean property, provides an easier-to-use, static method version of <code>Object.prototype.hasOwnProperty</code>. </p> <h2>Deprecations, and Removals</h2><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h4>Block ports 989 and 990</h4><p><a href=\"https://www.chromestatus.com/feature/5678858554572800\">Connections to HTTP, HTTPS or FTP servers on ports 989 and 990 now fail.</a> These ports are used by the FTPS protocol, which has never been implemented in Chrome. However, FTPS servers can be attacked in a cross-protocol attack by malicious web pages using carefully-crafted HTTPS requests. This is a mitigation for <a href=\"https://alpaca-attack.com/\">the ALPACA attack</a>. </p> <h4>Remove 3DES in TLS</h4><p>Chrome has <a href=\"https://www.chromestatus.com/feature/6678134168485888\">now removed support for the TLS_RSA_WITH_3DES_EDE_CBC_SHA</a> cipher suite. TLS_RSA_WITH_3DES_EDE_CBC_SHA is a remnant of the SSL 2.0 and SSL 3.0 era. 3DES in transport layer security (TLS) is vulnerable to the <a href=\"https://sweet32.info/\">Sweet32 attack</a>. Being a CBC cipher suite, it is also vulnerable to the <a href=\"https://en.wikipedia.org/wiki/Lucky_Thirteen_attack\">Lucky Thirteen</a> attack. The first replacement AES cipher suites were defined for TLS in RFC3268, published around 19 years ago, and there have been several iterations since.</p> <h4>WebAssembly Cross-Origin Module Sharing</h4> <p>WebAssembly module sharing between cross-origin but same-site environments <a href=\"https://chromestatus.com/feature/5650158039597056\">will be deprecated</a> to allow agent clusters to be scoped to origins long term. This follows a WebAssembly specification change, which has an impact on the platform as well.</p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Android WebView, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 93 is beta as of July 29, 2021.\n Origin Trials\nThis version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n Cross-Origin-Embedder-Policy: credentialless\nCross-origin no-CORS requests can now be made to omit credentials (cookies, client certificates, etc.) using the credentialless keyword. Similarly to COEP: require-corp, it can enable cross-origin isolation.\n Sites that wish to continue using SharedArrayBuffer must opt-in to cross-origin isolation. Today, COEP: require-corp exists, and is used to enable cross-origin isolation. It is functional and solid, but turns out to be difficult to deploy at scale, as it requires all subresources to explicitly opt-in. This is fine for some sites, but creates dependency problems for sites that gather content from users (Google Earth, social media generally, forums, etc.).\n Multi-Screen Window Placement\nThe Multi-Screen Window Placement API allows you to place windows on any display connected to your machine, store that placement, and make a window full-screen on any display. With this API, a presentation app can show slides on one screen and speaker notes on another. An art or music creation app can place palettes on a second screen. And a restaurant can show a touchscreen menu on a kiosk and a separate window for employees. Incorporating developer feedback from the first origin trial, the API enters a second origin trial with an improved shape and ergonomics.\n Window Controls Overlay for Installed Desktop Web Apps\nWindow controls overlay extends an app's client area to cover the entire window, including the title bar, and the window control buttons (close, maximize/restore, minimize). The web app developer is responsible for drawing and input-handling for the entire window except for the window controls overlay. Developers can use this feature to make their installed desktop web apps look like O.S. apps. For more information, see Customize the window controls overlay of your PWA's title bar.\n PWAs as URL Handlers\nPWA as URL Handlers allows apps like music.example.com to register themselves as URL handlers for URLs that match patterns like https://music.example.com, https://*.music.example.com, or https://🎵.example.com, so that links from outside of the PWA, for example, from an instant messenger application or an email client, open in the installed PWA rather than in a browser tab.\n Completed Origin Trials\nThe following features, previously in a Chrome origin trial, are now enabled by default.\n Subresource loading with Web Bundles\nWeb Bundles provides a new approach to load a large number of resources efficiently using a format that allows multiple resources to be bundled. This feature addresses issues with previous approaches to resource bundling. \n The output of some JavaScript bundlers does not interact well with the HTTP cache and configuring them can sometimes be difficult. Even with bundled JavaScript, execution needs to wait for all bytes to download. Ideally loading multiple subresources should use streaming and parallelization, which is not possible with one JavaScript file. For JavaScript modules, execution still needs to wait for an entire resource tree to download because of deterministic execution.\n WebXR Plane Detection API\nWebXR applications can now retrieve data about planes present in a user's environment, which enables augmented reality applications to create more immersive experiences. Without this feature, developers would have to resort to running their own computer vision algorithms on data from getUserMedia() (available on navigator and MediaDevices) in order to detect planes present in the users' environment. Such solutions have thus far been unable to match the quality and accuracy of native augmented reality capabilities or support world scale.\n Other features in this release\n AbortSignal.abort() Static Method\nAbortSignal.abort() is a static method that allows creating a new AbortSignal object that is already aborted. It is similar in spirit to Promise.reject(), and provides improved developer ergonomics.\n Web developers have found aborted AbortSignal objects to be useful for a variety of purposes. They signify to JavaScript APIs that no work should be done. Currently, creating an already-aborted AbortSignal object requires multiple lines of code. AbortSignal.abort() requires one:\nreturn AbortSignal.abort();\n CSS Flexbox: Support Alignment Keywords start, end, self-start, self-end, left, right\nThe flexbox and flex items now obey positional alignment keywords. Flexbox previously only obeyed center, flex-start, and flex-end. The additional alignment keywords (start, end, self-start, self-end, left, right) allow authors to more easily align the flex items in the face of varying writing modes and flex flows.\n Without these additional keywords, developers need to change the keyword values whenever they change the writing mode, text direction, or flex reversal properties (flex-direction: row-reverse, flex-direction:column-reverse or align-content: wrap-reverse). The keywords implemented here let them set alignment once.\n Error.cause Property\nThe Error() constructor supports a new options property called cause, which will be assigned to the error as a property. This allows errors to be chained without unnecessary and overelaborate formalities on wrapping the errors in conditions.\n Honor Media HTML Attribute for meta name=theme-color\nThe meta element's \"media\" attribute will be honored for meta[name=\"theme-color\"] so that web developers can adjust the theme color of their site based on a media query (dark and light modes for instance). The first one that matches will be picked.\n noplaybackrate in HTMLMediaElement.controlsList \nThe HTMLMediaElement.controlsList property now supports noplaybackrate, which allows websites to enabled or disable the playback speed control exposed by the browser. With browser vendors adding playback speed control to their media controls, developers should have a way to control the visibility of this new control. Try the new property on the noplaybackrate in HTMLMediaElement.controlsList Sample.\n Sec-CH-Prefers-Color-Scheme Client Hint Header\nThe CSS user preference media feature prefers-color-scheme has a potentially significant impact on the amount of CSS that needs to be delivered by a page and on the experience the user is going to have when the page loads. The new Sec-CH-Prefers-Color-Scheme client hint header allows sites to obtain the user's preference optionally at request time, allowing servers to inline the right CSS and therefore avoid a flash of incorrect color theme.\nUser-Agent Client Hints API Updates\nThis version of Chrome adds four new features and changes to the User-Agent client hints API.\n \nSec-CH-UA-Bitness: a request header that gives a server information about the bitness of the architecture of the platform on which a given user agent is executing. Bitness is the number of bits comprising the basic value a particular system can evaluate.\n\nMake Sec-CH-UA-Platform a low-entropy hint: Sec-CH-UA-Platform is a request header that gives a server information about the platform on which a given user agent is executing.\n\nAdds low-entropy hints to UADataValues.getHighEntropyValues(): If a hint moves from high to low-entropy, this future proofs any code relying on it.\n \nImproves NavigatorUAData.toJSON() method: This method now returns useful data.\n \nLow-entropy hints are those that don't give away too much information, or give information that would be too easy to discover in other ways to realistically hide. In the context of client hints, this means that these hints are available in every request, whether or not the origin involved requested it or whether the frame involved is a first or third party context.\n WebOTP API: Cross-Device Support\nThe WebOTP API will now be supported on desktop when both Chrome on Desktop and Android Chrome are logged in using the same Google account. The WebOPT API provides the ability to programmatically read a one-time code from specially-formatted SMS messages addressed to their origin, reducing user friction during sign-on. Previously, this was only available on mobile devices where SMS was supported.\n \n JavaScript\nThis version of Chrome incorporates version 9.3 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete list of recent features in the V8 release notes.\n Object.hasOwn\nObject.hasOwn, a new boolean property, provides an easier-to-use, static method version of Object.prototype.hasOwnProperty. \n Deprecations, and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n Block ports 989 and 990\nConnections to HTTP, HTTPS or FTP servers on ports 989 and 990 now fail. These ports are used by the FTPS protocol, which has never been implemented in Chrome. However, FTPS servers can be attacked in a cross-protocol attack by malicious web pages using carefully-crafted HTTPS requests. This is a mitigation for the ALPACA attack. \n Remove 3DES in TLS\nChrome has now removed support for the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher suite. TLS_RSA_WITH_3DES_EDE_CBC_SHA is a remnant of the SSL 2.0 and SSL 3.0 era. 3DES in transport layer security (TLS) is vulnerable to the Sweet32 attack. Being a CBC cipher suite, it is also vulnerable to the Lucky Thirteen attack. The first replacement AES cipher suites were defined for TLS in RFC3268, published around 19 years ago, and there have been several iterations since.\n WebAssembly Cross-Origin Module Sharing\n WebAssembly module sharing between cross-origin but same-site environments will be deprecated to allow agent clusters to be scoped to origins long term. This follows a WebAssembly specification change, which has an impact on the platform as well.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-7208317218931227459",
        "isoDate": "2021-07-29T19:00:00.007Z"
    },
    {
        "title": "Faster and more efficient phishing detection in M92",
        "link": "http://blog.chromium.org/2021/07/m92-faster-and-more-efficient-phishing-detection.html",
        "pubDate": "2021-07-20T16:58:00.005Z",
        "author": "Chromium Blog",
        "content": "<div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-4BU0lSpgH3g/YPcBQ2o2QcI/AAAAAAAABnA/-7gMuWNFmWw9Gak6NF-mG-OW958qmScEACLcBGAsYHQ/s1999/image1.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"830\" data-original-width=\"1999\" height=\"266\" src=\"https://1.bp.blogspot.com/-4BU0lSpgH3g/YPcBQ2o2QcI/AAAAAAAABnA/-7gMuWNFmWw9Gak6NF-mG-OW958qmScEACLcBGAsYHQ/w640-h266/image1.png\" width=\"640\" /></a></div><br /><div><br /></div><br /><i>Keeping Chrome users safe as they browse the web is crucially important to Chrome; in fact, security has always been one of our four <a href=\"https://www.chromium.org/developers/core-principles\">core principles</a>. In some cases, security can come at the expense of performance. In our next post in <a href=\"https://blog.chromium.org/search/label/the%20fast%20and%20the%20curious\">The Fast and the Curious</a> series, we are excited to share how improvements to our phishing detection algorithms keeps users safe online. With these improvements, phishing detection is now <b>50 times faster and drains less battery</b>.</i><br /><br /><h2 style=\"text-align: left;\">Phishing detection</h2>Every time you navigate to a new page, Chrome evaluates a collection of signals about the page to see if it matches those of phishing sites. To do that, we compare the color profile of the visited page - that’s the range and frequency of the colors present on the page -  with the color profiles of common pages. For example in the image below, we can see that the colors are mostly orange, followed by green and then a touch of purple. <br /><br /><br /><a href=\"https://1.bp.blogspot.com/-LM3Ymd5pd5U/YPcCQdCFZkI/AAAAAAAABnI/GuSBfvCx5R4w5VfGFoVpKMOKcf4kOTeSACLcBGAsYHQ/s1386/image3.jpg\" style=\"margin-left: 1em; margin-right: 1em; text-align: center;\"><img border=\"0\" data-original-height=\"920\" data-original-width=\"1386\" height=\"424\" src=\"https://1.bp.blogspot.com/-LM3Ymd5pd5U/YPcCQdCFZkI/AAAAAAAABnI/GuSBfvCx5R4w5VfGFoVpKMOKcf4kOTeSACLcBGAsYHQ/w640-h424/image3.jpg\" width=\"640\" /></a><br /><br /><br />If the site matches a known phishing site, Chrome warns you to protect your personal information and prevent you from exposing your credentials.<div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-Y2wKKKEehng/YPcCiIU1c_I/AAAAAAAABnQ/8pWOTs4gXqscZxe8DtS7VbqJmYbsNgemACLcBGAsYHQ/s909/image7.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"509\" data-original-width=\"909\" height=\"358\" src=\"https://1.bp.blogspot.com/-Y2wKKKEehng/YPcCiIU1c_I/AAAAAAAABnQ/8pWOTs4gXqscZxe8DtS7VbqJmYbsNgemACLcBGAsYHQ/w640-h358/image7.png\" width=\"640\" /></a></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div><i>What you will see if a phishing attempt is detected</i><br /><br />To preserve your privacy, by default Chrome's <a href=\"https://safebrowsing.google.com/\">Safe Browsing</a> mode never sends any images outside the browser. While this is great for privacy, it means that your machine has to do all the work to analyze the image. <br /><br />Image processing can often generate heavy workloads because analyzing the image requires an evaluation of each pixel in what is commonly known as a “pixel loop.” Some modern monitors display upwards of 14 million pixels, so even simple operations on each of those pixels can add up to a lot of CPU use! For phishing detection, the operation that takes place on each pixel is the counting of its basic colors.<br /><br />Here is what this looks like. The counts are stored in an associative data structure called a hashmap. For each pixel, we extract its RGB color values and store the counts in one of 3 different hashmaps -- one for each color.<br /><br /><br /><a href=\"https://1.bp.blogspot.com/-BXXsKJlC-_U/YPcCynGwN9I/AAAAAAAABnY/MgR3-sUhI-MdJ3HczePx3oRcOQoulSlPgCLcBGAsYHQ/s1386/image2.jpg\" style=\"margin-left: 1em; margin-right: 1em; text-align: center;\"><img border=\"0\" data-original-height=\"921\" data-original-width=\"1386\" height=\"426\" src=\"https://1.bp.blogspot.com/-BXXsKJlC-_U/YPcCynGwN9I/AAAAAAAABnY/MgR3-sUhI-MdJ3HczePx3oRcOQoulSlPgCLcBGAsYHQ/w640-h426/image2.jpg\" width=\"640\" /></a><br /><br /><br /><h2 style=\"text-align: left;\">Making it more efficient</h2>Adding one item to a hashmap is fast, but we have to do this for millions of pixels. We try to avoid reducing the number of pixels to avoid compromising the quality of the analysis. However, the computation itself can be improved. <br /><br />Our improvements to the pipeline look like this:</div><div><ul style=\"text-align: left;\"><li>The code now avoids keeping track of RGB channels in three different hashmaps and instead uses only one to index by color. Three times less counting!</li><li>Consecutive pixels are summed before being counted in the hashmap. For a site with a uniform background color, this can reduce the hashmap overhead to almost nothing.</li></ul>Here is what the counting of the colors looks like now. Notice how there are significantly fewer operations on the hashmap:<br /><br /><br /><a href=\"https://1.bp.blogspot.com/-tXOqeIjnhLs/YPcDF0ZIvkI/AAAAAAAABng/G5ZOvgMv_CAyDND5_mRo52bez6jeaaJ7ACLcBGAsYHQ/s1386/image5.jpg\" style=\"margin-left: 1em; margin-right: 1em; text-align: center;\"><img border=\"0\" data-original-height=\"921\" data-original-width=\"1386\" height=\"426\" src=\"https://1.bp.blogspot.com/-tXOqeIjnhLs/YPcDF0ZIvkI/AAAAAAAABng/G5ZOvgMv_CAyDND5_mRo52bez6jeaaJ7ACLcBGAsYHQ/w640-h426/image5.jpg\" width=\"640\" /></a><br /><br /><br /><h2 style=\"text-align: left;\">How much faster did this get?</h2>Starting with M92, Chrome now executes image-based phishing classification up to <b>50 times faster</b> at the 50th percentile and <b>2.5 times faster</b> at the 99th percentile. On average, users will get their phishing classification results after <b>100 milliseconds, instead of 1.8 seconds</b>.<br /><br />This benefits you in two ways as you use Chrome. First and foremost, using less CPU time to achieve the same work improves general performance. Less CPU time means less battery drain and less time with spinning fans.</div><div><br /></div><div>Second, getting the results faster means Chrome can warn you earlier. The optimization brought the percentage of requests that took more than 5 seconds to process from 16.25% to less than 1.6%. This speed improvement makes a real difference in security - especially when it comes to stopping you from  entering your password in a malicious site!</div><div><br /></div><div>Overall, these changes achieve a reduction of almost <b>1.2% of the total CPU</b> time used by all Chrome renderer processes and utility processes.</div><div><br />At Chrome’s scale, even minor algorithm improvements can result in major energy efficiency gains in aggregate. Here’s to many more centuries of CPU time saved!<br /><br />Stay tuned for many more performance improvements to come!<br /><br />Posted by Olivier Li Shing Tat-Dupuis, Chrome Developer<br /><br /><i>Data source for all statistics: <a href=\"https://www.google.com/chrome/privacy/whitepaper.html#usagestats\">Real-world data</a> anonymously aggregated from Chrome clients.</i></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><br /><br />",
        "contentSnippet": "Keeping Chrome users safe as they browse the web is crucially important to Chrome; in fact, security has always been one of our four core principles. In some cases, security can come at the expense of performance. In our next post in The Fast and the Curious series, we are excited to share how improvements to our phishing detection algorithms keeps users safe online. With these improvements, phishing detection is now 50 times faster and drains less battery.\n\nPhishing detection\nEvery time you navigate to a new page, Chrome evaluates a collection of signals about the page to see if it matches those of phishing sites. To do that, we compare the color profile of the visited page - that’s the range and frequency of the colors present on the page -  with the color profiles of common pages. For example in the image below, we can see that the colors are mostly orange, followed by green and then a touch of purple. \n\n\n\nIf the site matches a known phishing site, Chrome warns you to protect your personal information and prevent you from exposing your credentials.\n\n\n\n\n\n\nWhat you will see if a phishing attempt is detected\nTo preserve your privacy, by default Chrome's Safe Browsing mode never sends any images outside the browser. While this is great for privacy, it means that your machine has to do all the work to analyze the image. \nImage processing can often generate heavy workloads because analyzing the image requires an evaluation of each pixel in what is commonly known as a “pixel loop.” Some modern monitors display upwards of 14 million pixels, so even simple operations on each of those pixels can add up to a lot of CPU use! For phishing detection, the operation that takes place on each pixel is the counting of its basic colors.\nHere is what this looks like. The counts are stored in an associative data structure called a hashmap. For each pixel, we extract its RGB color values and store the counts in one of 3 different hashmaps -- one for each color.\n\n\n\nMaking it more efficient\nAdding one item to a hashmap is fast, but we have to do this for millions of pixels. We try to avoid reducing the number of pixels to avoid compromising the quality of the analysis. However, the computation itself can be improved. \nOur improvements to the pipeline look like this:\n\nThe code now avoids keeping track of RGB channels in three different hashmaps and instead uses only one to index by color. Three times less counting!\nConsecutive pixels are summed before being counted in the hashmap. For a site with a uniform background color, this can reduce the hashmap overhead to almost nothing.\nHere is what the counting of the colors looks like now. Notice how there are significantly fewer operations on the hashmap:\n\n\n\nHow much faster did this get?\nStarting with M92, Chrome now executes image-based phishing classification up to 50 times faster at the 50th percentile and 2.5 times faster at the 99th percentile. On average, users will get their phishing classification results after 100 milliseconds, instead of 1.8 seconds.\nThis benefits you in two ways as you use Chrome. First and foremost, using less CPU time to achieve the same work improves general performance. Less CPU time means less battery drain and less time with spinning fans.\n\n\nSecond, getting the results faster means Chrome can warn you earlier. The optimization brought the percentage of requests that took more than 5 seconds to process from 16.25% to less than 1.6%. This speed improvement makes a real difference in security - especially when it comes to stopping you from  entering your password in a malicious site!\n\n\nOverall, these changes achieve a reduction of almost 1.2% of the total CPU time used by all Chrome renderer processes and utility processes.\n\nAt Chrome’s scale, even minor algorithm improvements can result in major energy efficiency gains in aggregate. Here’s to many more centuries of CPU time saved!\nStay tuned for many more performance improvements to come!\nPosted by Olivier Li Shing Tat-Dupuis, Chrome Developer\nData source for all statistics: Real-world data anonymously aggregated from Chrome clients.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-8971910750748560738",
        "isoDate": "2021-07-20T16:58:00.005Z"
    },
    {
        "title": " Increasing HTTPS adoption",
        "link": "http://blog.chromium.org/2021/07/increasing-https-adoption.html",
        "pubDate": "2021-07-14T17:00:00.000Z",
        "author": "Chromium Blog",
        "content": "<span id=\"docs-internal-guid-fefb39b5-7fff-6608-0a37-e5d1089cba7d\"><div><br /></div><div>When a browser connects to websites over HTTPS (vs. HTTP), eavesdroppers and attackers on the network can't intercept or alter the data that's shared over that connection (including personal info, or even the page itself). This level of privacy and security is vital for the web ecosystem, so Chrome <a href=\"https://blog.chromium.org/2019/10/no-more-mixed-messages-about-https.html\" target=\"_blank\">continues</a> <a href=\"https://blog.chromium.org/2020/02/protecting-users-from-insecure.html\" target=\"_blank\">to</a> <a href=\"https://blog.chromium.org/2021/03/a-safer-default-for-navigation-https.html\" target=\"_blank\">invest</a> in making HTTPS more widely supported.</div><div><br /></div><div>Thankfully, HTTPS adoption has come <a href=\"https://transparencyreport.google.com/https/overview?hl=en\" target=\"_blank\">a long way in recent years</a>, and most operating systems now see 90%+ of page loads over HTTPS in Chrome. Still, there's more we can do to help make HTTPS the preferred protocol on the web, and better protect users on the remaining slice of the web that doesn’t yet support HTTPS, so today we're sharing some future work in this area.</div><div><br /></div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Opting in to an HTTPS-First World</h2><div><br /></div><div>Beginning in M94, Chrome will offer HTTPS-First Mode, which will attempt to upgrade all page loads to HTTPS and display a full-page warning before loading sites that don’t support it. Users who enable this mode gain confidence that Chrome is connecting them to sites over HTTPS whenever possible, and that they will see a warning before connecting to sites over HTTP. Based on ecosystem feedback, we’ll explore making HTTPS-First mode the default for all users in the future. Mozilla has also shared their intent to make <a href=\"https://blog.mozilla.org/security/2020/11/17/firefox-83-introduces-https-only-mode/\" target=\"_blank\">HTTPS-only mode</a> the future of web browsing in Firefox.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\"><br />Experimenting with the lock icon</h2><div>As we approach an HTTPS-first future, we're also re-examining the lock icon that browsers typically show when a site loads over HTTPS. In particular, <a href=\"https://research.google/pubs/pub45366/\" target=\"_blank\">our research</a> indicates that users often associate this icon with a site being trustworthy, when in fact it's only the connection that's secure. In a recent study, we found that only 11% of participants could correctly identify the meaning of the lock icon. To try and reduce this confusion, Chrome will run an experiment in M93 that replaces the lock in the address bar with a more neutral entry point to Page Info (example below). We hope that this experiment will improve the discoverability of critical privacy and security information and controls provided in Page Info, such as site permissions. Importantly, a \"Not Secure\" indicator will continue to show on sites without HTTPS support, and the experiment includes an enterprise policy in case organizations want to opt-out. In all cases, we'll provide advance notice if we decide to move ahead with a full launch.</div><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: Nunito, sans-serif; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"border: none; display: inline-block; height: 470px; overflow: hidden; width: 636px;\"><img height=\"494.4881755605533\" src=\"https://lh5.googleusercontent.com/qX5CZSRNrhxon9VmUvf5hM_IGM5nYKrNSQgmjc4m08GnaIXvdV58jxpL41964FdzVswxfvsQe3zaSjP-nhW7_SzXtxAi8lw_Om0qTGLzDt0BybYO6XRGRaQCrDqHJMhmKOJooLOFafyTr2pV4kWds2okike_-YNzhjpwbZ1T3RhH2G-2\" style=\"margin-left: -24px; margin-top: -24.4881755605536px;\" width=\"660\" /></span></span><span style=\"font-family: Nunito, sans-serif; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><br /><br /></span></p><br /><br /></span><h2 style=\"text-align: left;\"><span>Protecting users on the HTTP web</span></h2><br />While we are excited to see users adopt HTTPS-First Mode in future versions of Chrome, HTTP connections will still continue to be supported and Chrome will take additional steps to protect and inform users whenever they are using insecure connections. Continuing from our past efforts to <a href=\"https://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\" target=\"_blank\">restrict new features to secure origins</a> and <a href=\"https://www.chromium.org/Home/chromium-security/deprecating-powerful-features-on-insecure-origins\" target=\"_blank\">deprecate powerful features on insecure origins</a>, we’ll evaluate a broad set of web platform features to determine if they should be limited or restricted on HTTP webpages. <br /><br />In order to focus on changes that provide the greatest security improvements to our users, we are relying on a set of guiding principles to prioritize our future work in this area: <br /><br /><ul style=\"text-align: left;\"><li>Better inform users when making trust decisions about sites over insecure connections</li><li>Limit the ability for sites to opt out of security policies over insecure connections</li><li>Restrict how, and for how long, Chrome stores site content provided over insecure connections</li></ul>A deeper explanation of how we plan to act on these principles, as well as an updated list of affected features will be maintained on the <a href=\"https://www.chromium.org/Home/chromium-security/deprecating-powerful-features-on-insecure-origins\" target=\"_blank\">Chromium wiki</a> and we are excited to announce more details later this year.<div><br /></div><div>Posted by&nbsp;Shweta Panditrao, Devon O'Brien, Emily Stark, Google Chrome team<br /><span><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><br /></p></span></div>",
        "contentSnippet": "When a browser connects to websites over HTTPS (vs. HTTP), eavesdroppers and attackers on the network can't intercept or alter the data that's shared over that connection (including personal info, or even the page itself). This level of privacy and security is vital for the web ecosystem, so Chrome continues to invest in making HTTPS more widely supported.\n\n\nThankfully, HTTPS adoption has come a long way in recent years, and most operating systems now see 90%+ of page loads over HTTPS in Chrome. Still, there's more we can do to help make HTTPS the preferred protocol on the web, and better protect users on the remaining slice of the web that doesn’t yet support HTTPS, so today we're sharing some future work in this area.\n\n\n\n\n\nOpting in to an HTTPS-First World\n\n\nBeginning in M94, Chrome will offer HTTPS-First Mode, which will attempt to upgrade all page loads to HTTPS and display a full-page warning before loading sites that don’t support it. Users who enable this mode gain confidence that Chrome is connecting them to sites over HTTPS whenever possible, and that they will see a warning before connecting to sites over HTTP. Based on ecosystem feedback, we’ll explore making HTTPS-First mode the default for all users in the future. Mozilla has also shared their intent to make HTTPS-only mode the future of web browsing in Firefox.\n\n\n\n\nExperimenting with the lock icon\nAs we approach an HTTPS-first future, we're also re-examining the lock icon that browsers typically show when a site loads over HTTPS. In particular, our research indicates that users often associate this icon with a site being trustworthy, when in fact it's only the connection that's secure. In a recent study, we found that only 11% of participants could correctly identify the meaning of the lock icon. To try and reduce this confusion, Chrome will run an experiment in M93 that replaces the lock in the address bar with a more neutral entry point to Page Info (example below). We hope that this experiment will improve the discoverability of critical privacy and security information and controls provided in Page Info, such as site permissions. Importantly, a \"Not Secure\" indicator will continue to show on sites without HTTPS support, and the experiment includes an enterprise policy in case organizations want to opt-out. In all cases, we'll provide advance notice if we decide to move ahead with a full launch.\n\n\n\n\n\nProtecting users on the HTTP web\nWhile we are excited to see users adopt HTTPS-First Mode in future versions of Chrome, HTTP connections will still continue to be supported and Chrome will take additional steps to protect and inform users whenever they are using insecure connections. Continuing from our past efforts to restrict new features to secure origins and deprecate powerful features on insecure origins, we’ll evaluate a broad set of web platform features to determine if they should be limited or restricted on HTTP webpages. \nIn order to focus on changes that provide the greatest security improvements to our users, we are relying on a set of guiding principles to prioritize our future work in this area: \n\nBetter inform users when making trust decisions about sites over insecure connections\nLimit the ability for sites to opt out of security policies over insecure connections\nRestrict how, and for how long, Chrome stores site content provided over insecure connections\nA deeper explanation of how we plan to act on these principles, as well as an updated list of affected features will be maintained on the Chromium wiki and we are excited to announce more details later this year.\n\nPosted by Shweta Panditrao, Devon O'Brien, Emily Stark, Google Chrome team",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-1575640282796820531",
        "isoDate": "2021-07-14T17:00:00.000Z"
    },
    {
        "title": "Changes to Chrome OS’s release cycle",
        "link": "http://blog.chromium.org/2021/06/changes-to-chrome-oss-release-cycle.html",
        "pubDate": "2021-06-11T14:58:00.000Z",
        "author": "Chromium Blog",
        "content": "We <a href=\"https://blog.chromium.org/2021/03/speeding-up-release-cycle.html\" target=\"_blank\">previously announced </a>that Chrome will soon release a new milestone every 4 weeks, starting with Chrome 94 in Q3 of 2021. We’re excited to also share our plans today for adjusting the Chrome OS release schedule. <br /><br />To deliver new features more rapidly to consumers while also continuing to prioritize the key pillars of Chrome OS – security, stability, speed and simplicity – Chrome OS will move to a 4-week stable channel starting with M96 in Q4. For enterprise and education users, Chrome OS will also introduce a new channel with a 6-month update cadence by M96. More details to be announced soon.<br /><br />To bridge the gap between M94 when Chrome moves to a four week release and M96, Chrome OS will skip M95 (see the updated Chrome <a href=\"https://chromiumdash.appspot.com/schedule\" target=\"_blank\">schedule page</a> for milestone-specific details). <br /><br />As we head into our next decade, these changes enable us to evolve Chrome OS to keep helping people get things done and to provide more helpful and secure experiences.<br /><br /><br />Marina Kazatcker, Chrome OS Release TPM Lead<div><br /></div>",
        "contentSnippet": "We previously announced that Chrome will soon release a new milestone every 4 weeks, starting with Chrome 94 in Q3 of 2021. We’re excited to also share our plans today for adjusting the Chrome OS release schedule. \nTo deliver new features more rapidly to consumers while also continuing to prioritize the key pillars of Chrome OS – security, stability, speed and simplicity – Chrome OS will move to a 4-week stable channel starting with M96 in Q4. For enterprise and education users, Chrome OS will also introduce a new channel with a 6-month update cadence by M96. More details to be announced soon.\nTo bridge the gap between M94 when Chrome moves to a four week release and M96, Chrome OS will skip M95 (see the updated Chrome schedule page for milestone-specific details). \nAs we head into our next decade, these changes enable us to evolve Chrome OS to keep helping people get things done and to provide more helpful and secure experiences.\n\nMarina Kazatcker, Chrome OS Release TPM Lead",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-5197599915716633020",
        "isoDate": "2021-06-11T14:58:00.000Z"
    },
    {
        "title": "Chrome 92: Web Apps as File Handlers, New JavaScript Features, and More",
        "link": "http://blog.chromium.org/2021/06/chrome-92-web-apps-as-file-handlers-new.html",
        "pubDate": "2021-06-03T19:50:00.002Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D76\">ChromeStatus.com</a>. Chrome 92 is beta as of June 3, 2021</p> <h2>File Handling API</h2><p>Now that web apps are capable of reading and writing files, the next logical step is to let developers declare web apps as file handlers for files they create and process. The File Handling API allows you to do exactly this. For example, after a text editor PWA has registered itself as a file handler, you can right-click a .txt file in your operating system's file manager and instruct this PWA to (always or just once) open .txt files. This means PWAs are just a (double) click away from the file manager. </p><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-IScCsy5rb6E/YLkyJ2FAubI/AAAAAAAABkk/y73Zm4CeLbggt5hkWBR1zFD59QQamDbqACLcBGAsYHQ/s309/excontext.png\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"The Excalidraw context menu.\" border=\"0\" data-original-height=\"159\" data-original-width=\"309\" src=\"https://1.bp.blogspot.com/-IScCsy5rb6E/YLkyJ2FAubI/AAAAAAAABkk/y73Zm4CeLbggt5hkWBR1zFD59QQamDbqACLcBGAsYHQ/s16000/excontext.png\" /></a></div><br /><p><br /></p>  <p>This improves the user experience for PWA use cases, making them more like OS apps than they are already. For example:</p> <ul><li>Office applications like text editors, spreadsheet apps, and slideshow creators.</li><li>Graphics editors and drawing tools.</li><li>Video game level editor tools.</li></ul> <p>File Handling is starting an origin trial in 92 that is expected to run until around the end of August, 2021. For more information on this feature, see <a href=\"https://web.dev/file-handling/\">Let web applications be file handlers</a>. For information about other origin trials in this release, see <a href=\"#Origin-Trials\">Origin Trials</a>, below.</p> <h2>Origin Trials</h2><p>This version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h3>New Origin Trials</h3> <h4>Shared Element Transitions</h4><p><a href=\"https://www.chromestatus.com/feature/5193009714954240\">Shared Element Transitions</a> allows a simple set of transitions in both single-page applications (SPAs) and multi-page applications (MPAs). This enhances the visual polish of pages with minimal effort by letting developers select from a set of user-agent provided transition effects. Without this, single-page app transitions are difficult since they require a careful coordination of animations and DOM manipulations to achieve the desired effect. Multi-page app transitions are, for the most part, not possible since each page can only control the contents of its own view. This origin trial is only for SPA use cases.</p> <h2>Other features in this release</h2> <h3>Change in Allowed App Shortcuts</h3><p>Most Android launchers now allow only three app shortcuts instead of the previously allowed four. A shortcut to the site settings was added to the application icon in the Android launcher, taking one of the available shortcut slots for the app. For more information, see <a href=\"https://web.dev/app-shortcuts/\">Get things done quickly with app shortcuts</a>.</p> <h3>CSS</h3> <h4>size-adjust Descriptor for @font-face</h4><p><a href=\"https://www.chromestatus.com/feature/5662073285509120\">Adds the size-adjust descriptor for <code>@font-face</code></a> allowing scaling of glyph sizes for a particular font face without affecting the CSS <code>font-size</code> and derived metrics such as em. CSS <code>font-size</code> can be seen as a scale factor for a box that the font draws in. Glyph sizes within that box vary between fonts, and size-adjust enables harmonising them across different fonts. That's why it reduces cumulative layout shift by matching up the fallback font and primary web font using this descriptor.</p> <h3>Imperative Slot Distribution Behavior</h3><p><a href=\"https://www.chromestatus.com/feature/4979822998585344\">Imperative slotting</a> allows node-to-slot assignments without needing the slot attribute in markup.  This enables dynamic slotting behavior based on input conditions and types. The feature originally shipped in <a href=\"https://chromestatus.com/feature/5711021289242624\">Chrome 86</a>; in this release some adjustments to the API have been made to ensure interoperability with other browsers.</p> <h3>JavaScript</h3><p>This version of Chrome incorporates version 9.2 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h4>Add dayPeriod option for Intl.DateTimeFormat</h4><p>A <a href=\"https://www.chromestatus.com/feature/6520669959356416\">dayPeriod option</a> (part of ECMA402 2021) has been added to the <code>Intl.DateTimeFormat()</code> method so the caller can format times such as \"7 in the morning\", \"11 in the morning\",  \"12 noon\", \"1 in the afternoon\", \"6 in the evening\", \"10 at night\" (or in Chinese, \"清晨7時\", \"上午11時\", \"中午12時\", \"下午1時\" ,\"下午6時\" ,\"晚上10時\").</p> <p>This enhances <code>Intl.DateTimeFormat()</code> to match what is already possible in C++ and Java by calling ICU and ICU4J. Without this feature, developers need to either format the quarter in the server or ship a set of day period patterns and hour to day period mappings from the server to client to perform such tasks.</p> <h4>Relative Indexing Method for Array, String, and TypedArrays</h4><p><a href=\"https://www.chromestatus.com/feature/6123640410079232\">Adds a new method named <code>at()</code></a>, to <code>Array.prototype</code>, <code>String.prototype</code>, and the <code>TypedArray</code> prototypes, that permit relative indexing with negative indices. For example:<br /><br /><code>let arr = [1,2,3,4];<br />arr.at(-1); // Returns 4</code></p> <h4>Intl BestFitMatcher by Using ICU LocaleMatcher</h4><p>The ICU LocaleMatcher <a href=\"https://www.chromestatus.com/feature/5407573287108608\">now implements the BestFitMatcher</a> abstract operation to better match locale data. </p> <h4>SharedArrayBuffers on Desktop Platforms Restricted to Cross-Origin Isolated Environments</h4><p><code>SharedArrayBuffers</code> on desktop platforms are now restricted to cross-origin isolated environments, matching the behavior recently shipped on Android and Firefox. A Cross-origin isolated page is considered a secure environment because it blocks loading cross-origin resources that are not opt-in and communicating with cross-origin windows. Only pages that opt-in to cross-origin isolation will be able to use <code>SharedArrayBuffers</code>. Learn more about the upcoming options at <a href=\"https://developer.chrome.com/blog/enabling-shared-array-buffer/\"><code>SharedArrayBuffer</code> updates in Android Chrome 88 and Desktop Chrome 92</a>.</p> <h3>Media Session API: Video conferencing actions</h3><p>Adds actions to the Media Session API, specifically <code>\"togglemicrophone\"</code>, <code>\"togglecamera\"</code>, and <code>\"hangup\"</code>. This enables developers of video conferencing websites to handle these actions from the browser interface. For example, if the user puts their video call into a picture-in-picture window, the browser could display buttons for mute/unmute, turn-on/turn-off camera, and hanging up. When the user clicks these, the website handles them through the Media Session API. For more information, see the section from <a href=\"https://web.dev/media-session/#video-conferencing-actions\">our recent article</a>, or try <a href=\"https://googlechrome.github.io/samples/media-session/video-conferencing.html\">our demo</a>.</p> <h3>Tainted Origin Flag applied to Resource Timing</h3><p>Chrome now <a href=\"https://www.chromestatus.com/feature/5665918254317568\">accounts for the tainted origin flag</a> when computing whether a fetched resource passes the timing allow origin check. The timing allow origin check is used in resource timing to determine whether the page can receive detailed timing information about a resource used in the page. The tainted origin flag impacts this check in cases where there are multiple redirects that cross origins. In those cases, the header should be '*'. In other words, it can no longer be a specific origin.</p> <p>If a resource performs two cross-origin crosses (via redirects), then the developer needs to use <code>Timing-Allow-Origin: *</code> for the checks to pass. For example if a page on origin A fetches a resource on origin B, which redirects to a resource on origin C, then the tainted origin flag is set and the final resource needs to have <code>Timing-Allow-Origin: *</code> in order to receive detailed timing information.\"</p><h3 style=\"text-align: left;\">URL Protocol Handler Registration for PWAs</h3><p>Web applications can now register themselves as handlers of custom URL protocols or schemes using their web app manifests. Operating system applications often register themselves as protocol handlers to increase discoverability and usage. Websites can already register to handle schemes via registerProtocolHandler(), it is desirable to have web apps be first-class citizens and be launched directly when a custom-scheme link is invoked.&nbsp;</p> <h3>Web Bluetooth Manufacturer Data Filter</h3><p>The Web Bluetooth API can now filter based on manufacturer data such as vendor ID and product ID. Developers have been able to prompt users through a browser picker to select a nearby Bluetooth device that matches their advertised name and services. However it hasn't been possible to filter nearby Bluetooth devices based on advertised manufacturer specific data. Manufacturer data is specified through new properties on options.filters, which is passed to <code>Bluetooth.requestDevice()</code>. For more information, see <a href=\"https://web.dev/bluetooth/#manufacturer-data-filter\">Communicating with Bluetooth devices over JavaScript</a> or try <a href=\"https://googlechrome.github.io/samples/web-bluetooth/manufacturer-data-filter.html\">our demo</a>.</p> <h2>Deprecations and Removals</h2><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h3>Payment Handlers for Standardized Payment Method Identifiers</h3><p>This feature, which enabled web-based payment handlers to receive <code>paymentrequest</code> events with non-URL, but standardized payment method identifiers, such as <code>\"basic-card\"</code> or <code>\"tokenized-card\"</code>, <a href=\"https://www.chromestatus.com/feature/5407573287108608\">has been removed</a>.</p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 92 is beta as of June 3, 2021\n File Handling API\nNow that web apps are capable of reading and writing files, the next logical step is to let developers declare web apps as file handlers for files they create and process. The File Handling API allows you to do exactly this. For example, after a text editor PWA has registered itself as a file handler, you can right-click a .txt file in your operating system's file manager and instruct this PWA to (always or just once) open .txt files. This means PWAs are just a (double) click away from the file manager. \n\n\n\n  \nThis improves the user experience for PWA use cases, making them more like OS apps than they are already. For example:\n \nOffice applications like text editors, spreadsheet apps, and slideshow creators.\nGraphics editors and drawing tools.\nVideo game level editor tools.\n \nFile Handling is starting an origin trial in 92 that is expected to run until around the end of August, 2021. For more information on this feature, see Let web applications be file handlers. For information about other origin trials in this release, see Origin Trials, below.\n Origin Trials\nThis version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n Shared Element Transitions\nShared Element Transitions allows a simple set of transitions in both single-page applications (SPAs) and multi-page applications (MPAs). This enhances the visual polish of pages with minimal effort by letting developers select from a set of user-agent provided transition effects. Without this, single-page app transitions are difficult since they require a careful coordination of animations and DOM manipulations to achieve the desired effect. Multi-page app transitions are, for the most part, not possible since each page can only control the contents of its own view. This origin trial is only for SPA use cases.\n Other features in this release\n Change in Allowed App Shortcuts\nMost Android launchers now allow only three app shortcuts instead of the previously allowed four. A shortcut to the site settings was added to the application icon in the Android launcher, taking one of the available shortcut slots for the app. For more information, see Get things done quickly with app shortcuts.\n CSS\n size-adjust Descriptor for @font-face\nAdds the size-adjust descriptor for @font-face allowing scaling of glyph sizes for a particular font face without affecting the CSS font-size and derived metrics such as em. CSS font-size can be seen as a scale factor for a box that the font draws in. Glyph sizes within that box vary between fonts, and size-adjust enables harmonising them across different fonts. That's why it reduces cumulative layout shift by matching up the fallback font and primary web font using this descriptor.\n Imperative Slot Distribution Behavior\nImperative slotting allows node-to-slot assignments without needing the slot attribute in markup.  This enables dynamic slotting behavior based on input conditions and types. The feature originally shipped in Chrome 86; in this release some adjustments to the API have been made to ensure interoperability with other browsers.\n JavaScript\nThis version of Chrome incorporates version 9.2 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete list of recent features in the V8 release notes.\n Add dayPeriod option for Intl.DateTimeFormat\nA dayPeriod option (part of ECMA402 2021) has been added to the Intl.DateTimeFormat() method so the caller can format times such as \"7 in the morning\", \"11 in the morning\",  \"12 noon\", \"1 in the afternoon\", \"6 in the evening\", \"10 at night\" (or in Chinese, \"清晨7時\", \"上午11時\", \"中午12時\", \"下午1時\" ,\"下午6時\" ,\"晚上10時\").\n This enhances Intl.DateTimeFormat() to match what is already possible in C++ and Java by calling ICU and ICU4J. Without this feature, developers need to either format the quarter in the server or ship a set of day period patterns and hour to day period mappings from the server to client to perform such tasks.\n Relative Indexing Method for Array, String, and TypedArrays\nAdds a new method named at(), to Array.prototype, String.prototype, and the TypedArray prototypes, that permit relative indexing with negative indices. For example:\nlet arr = [1,2,3,4];\narr.at(-1); // Returns 4\n Intl BestFitMatcher by Using ICU LocaleMatcher\nThe ICU LocaleMatcher now implements the BestFitMatcher abstract operation to better match locale data. \n SharedArrayBuffers on Desktop Platforms Restricted to Cross-Origin Isolated Environments\nSharedArrayBuffers on desktop platforms are now restricted to cross-origin isolated environments, matching the behavior recently shipped on Android and Firefox. A Cross-origin isolated page is considered a secure environment because it blocks loading cross-origin resources that are not opt-in and communicating with cross-origin windows. Only pages that opt-in to cross-origin isolation will be able to use SharedArrayBuffers. Learn more about the upcoming options at SharedArrayBuffer updates in Android Chrome 88 and Desktop Chrome 92.\n Media Session API: Video conferencing actions\nAdds actions to the Media Session API, specifically \"togglemicrophone\", \"togglecamera\", and \"hangup\". This enables developers of video conferencing websites to handle these actions from the browser interface. For example, if the user puts their video call into a picture-in-picture window, the browser could display buttons for mute/unmute, turn-on/turn-off camera, and hanging up. When the user clicks these, the website handles them through the Media Session API. For more information, see the section from our recent article, or try our demo.\n Tainted Origin Flag applied to Resource Timing\nChrome now accounts for the tainted origin flag when computing whether a fetched resource passes the timing allow origin check. The timing allow origin check is used in resource timing to determine whether the page can receive detailed timing information about a resource used in the page. The tainted origin flag impacts this check in cases where there are multiple redirects that cross origins. In those cases, the header should be '*'. In other words, it can no longer be a specific origin.\n If a resource performs two cross-origin crosses (via redirects), then the developer needs to use Timing-Allow-Origin: * for the checks to pass. For example if a page on origin A fetches a resource on origin B, which redirects to a resource on origin C, then the tainted origin flag is set and the final resource needs to have Timing-Allow-Origin: * in order to receive detailed timing information.\"\nURL Protocol Handler Registration for PWAs\nWeb applications can now register themselves as handlers of custom URL protocols or schemes using their web app manifests. Operating system applications often register themselves as protocol handlers to increase discoverability and usage. Websites can already register to handle schemes via registerProtocolHandler(), it is desirable to have web apps be first-class citizens and be launched directly when a custom-scheme link is invoked. \n Web Bluetooth Manufacturer Data Filter\nThe Web Bluetooth API can now filter based on manufacturer data such as vendor ID and product ID. Developers have been able to prompt users through a browser picker to select a nearby Bluetooth device that matches their advertised name and services. However it hasn't been possible to filter nearby Bluetooth devices based on advertised manufacturer specific data. Manufacturer data is specified through new properties on options.filters, which is passed to Bluetooth.requestDevice(). For more information, see Communicating with Bluetooth devices over JavaScript or try our demo.\n Deprecations and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n Payment Handlers for Standardized Payment Method Identifiers\nThis feature, which enabled web-based payment handlers to receive paymentrequest events with non-URL, but standardized payment method identifiers, such as \"basic-card\" or \"tokenized-card\", has been removed.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-8337901719211750165",
        "isoDate": "2021-06-03T19:50:00.002Z"
    },
    {
        "title": "Chrome is up to 23% faster in M91 and saves over 17 years of CPU time daily",
        "link": "http://blog.chromium.org/2021/05/chrome-is-faster-in-m91.html",
        "pubDate": "2021-05-27T18:04:00.005Z",
        "author": "Chromium Blog",
        "content": "<i>Since the launch of Chrome in 2008, speed has been one of <a href=\"https://www.chromium.org/developers/core-principles\">the 4 core principles</a> that shape the work we do to deliver a highly performant browser. The V8 JavaScript compiler is a critical part of delivering maximum speed for the JavaScript that’s shipped on practically every web page. In our next post in <a href=\"https://blog.chromium.org/search/label/the%20fast%20and%20the%20curious\">The Fast and the Curious</a> series, we are excited to share how improvements to the V8 engine are delivering up to 23% faster performance.</i><div><br /></div><div><br />An important component of delivering a fast browser is fast JavaScript execution. In Chrome, that job is done by the V8 engine which executes over 78 years worth of JavaScript code on a daily basis. In M91 Chrome is now up to 23% faster with the launch of a <a href=\"https://v8.dev/blog/sparkplug\">new Sparkplug compiler</a> and <a href=\"https://v8.dev/blog/short-builtin-calls\">short builtin calls</a>, saving over 17 years of our users' CPU time each day! Sparkplug is a new JavaScript compiler that fills the gap between needing to start executing quickly and optimizing the code for maximum performance. Short builtin calls optimize where in memory we put generated code to avoid indirect jumps when calling functions.<br /><br /><br /><br /><h2 style=\"text-align: left;\">Sparkplug</h2>The V8 engine has multiple compilers which can make different tradeoffs throughout the various phases of executing JavaScript. Three years ago, we launched a new two-tier compiler system consisting of <a href=\"https://v8.dev/blog/launching-ignition-and-turbofan\">Ignition and Turbofan</a>. Ignition is a bytecode interpreter whose job is to start executing the JavaScript with as little delay as possible. Turbofan is the optimizing compiler that generates high-performance machine code based on information gathered during JavaScript execution; as a result, it starts up more slowly than Ignition’s bytecode compiler. Sparkplug strikes a balance between Ignition and Turbofan in that it does generate native machine code but does not depend on information gathered while executing the JavaScript code. This lets it start executing quickly while still generating relatively fast code. For a complete technical deep dive into what it took to make this new engine, please see our <a href=\"https://v8.dev/blog/sparkplug\">V8 blog post</a>.<div><br /></div><div><br /></div><div><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-yJxc0pFlyVI/YLBPd9WOsmI/AAAAAAAABj8/aTCXPUTin4wmkq89e8b6WHp3Vv64-oIkgCLcBGAsYHQ/s600/image1.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"60\" data-original-width=\"600\" height=\"64\" src=\"https://1.bp.blogspot.com/-yJxc0pFlyVI/YLBPd9WOsmI/AAAAAAAABj8/aTCXPUTin4wmkq89e8b6WHp3Vv64-oIkgCLcBGAsYHQ/w640-h64/image1.png\" width=\"640\" /></a></div><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><h2 style=\"text-align: left;\">Short builtins </h2>Short builtins is a mechanism by which the V8 engine optimizes the location in memory of generated code. When V8 generates CPU-specific code from JavaScript, it lays that code out in memory. This generated code will frequently call builtin functions, which are small snippets of code for handling common routines --everything from basic operations like adding two variables, to full-fledged functions in the JavaScript standard library. For some CPUs, calling functions that are further away from your generated code can cause CPU-internal optimizations (such as branch prediction logic) to fail. The fix for this is to copy the builtin functions into the same memory region as the generated code. This change is especially impactful for the new Apple M1 chip. Please see <a href=\"https://v8.dev/blog/short-builtin-calls\">our V8 blog post</a> to learn more about the impact across platforms of this feature.<div><br /></div><div>Stay turned for many more performance improvements to come!</div><div><br /></div><div>Posted by Thomas Nattestad, Chrome Product Manager<br /><br /><br /><i>Data source for all statistics: <a href=\"https://browserbench.org/Speedometer2.0/\">Speedometer 2.0</a>.</i><br /></div></div></div>",
        "contentSnippet": "Since the launch of Chrome in 2008, speed has been one of the 4 core principles that shape the work we do to deliver a highly performant browser. The V8 JavaScript compiler is a critical part of delivering maximum speed for the JavaScript that’s shipped on practically every web page. In our next post in The Fast and the Curious series, we are excited to share how improvements to the V8 engine are delivering up to 23% faster performance.\n\n\nAn important component of delivering a fast browser is fast JavaScript execution. In Chrome, that job is done by the V8 engine which executes over 78 years worth of JavaScript code on a daily basis. In M91 Chrome is now up to 23% faster with the launch of a new Sparkplug compiler and short builtin calls, saving over 17 years of our users' CPU time each day! Sparkplug is a new JavaScript compiler that fills the gap between needing to start executing quickly and optimizing the code for maximum performance. Short builtin calls optimize where in memory we put generated code to avoid indirect jumps when calling functions.\n\n\nSparkplug\nThe V8 engine has multiple compilers which can make different tradeoffs throughout the various phases of executing JavaScript. Three years ago, we launched a new two-tier compiler system consisting of Ignition and Turbofan. Ignition is a bytecode interpreter whose job is to start executing the JavaScript with as little delay as possible. Turbofan is the optimizing compiler that generates high-performance machine code based on information gathered during JavaScript execution; as a result, it starts up more slowly than Ignition’s bytecode compiler. Sparkplug strikes a balance between Ignition and Turbofan in that it does generate native machine code but does not depend on information gathered while executing the JavaScript code. This lets it start executing quickly while still generating relatively fast code. For a complete technical deep dive into what it took to make this new engine, please see our V8 blog post.\n\n\n\n\n\n\n\n\n\nShort builtins \nShort builtins is a mechanism by which the V8 engine optimizes the location in memory of generated code. When V8 generates CPU-specific code from JavaScript, it lays that code out in memory. This generated code will frequently call builtin functions, which are small snippets of code for handling common routines --everything from basic operations like adding two variables, to full-fledged functions in the JavaScript standard library. For some CPUs, calling functions that are further away from your generated code can cause CPU-internal optimizations (such as branch prediction logic) to fail. The fix for this is to copy the builtin functions into the same memory region as the generated code. This change is especially impactful for the new Apple M1 chip. Please see our V8 blog post to learn more about the impact across platforms of this feature.\n\nStay turned for many more performance improvements to come!\n\n\nPosted by Thomas Nattestad, Chrome Product Manager\n\nData source for all statistics: Speedometer 2.0.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-8629356725650964860",
        "isoDate": "2021-05-27T18:04:00.005Z"
    },
    {
        "title": "An experiment in helping users and web publishers create deeper connections on Chrome",
        "link": "http://blog.chromium.org/2021/05/an-experiment-in-helping-users-and-web.html",
        "pubDate": "2021-05-19T15:01:00.000Z",
        "author": "Chromium Blog",
        "content": "Today, people have many ways to keep up with their favorite websites, including subscribing to mailing lists, notifications and RSS. It’s a lot for any one person to manage, so we’re exploring how to simplify the experience of getting the latest and greatest from your favorite sites directly in Chrome, building on the open RSS web standard. Our vision is to help people build a direct connection with their favorite publishers and creators on the web.<br /><br />In the coming weeks, some Android users in the US on Chrome Canary may see an experimental Follow feature designed to help people get the latest content from sites they follow. Our goal for this feature is to allow people to follow the websites they care about, from the large publishers to the small neighborhood blogs, by tapping a Follow button in Chrome. When websites publish content, users can see updates from sites they have followed in a new Following section on the New Tab page:<div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-QrMUDarqUX4/YKUgD_oiD1I/AAAAAAAABg0/3HdCQBYz5gErf42PeUf0uJaffIHT66VcwCLcBGAsYHQ/s2048/WC%2BChrome%2Bblogpost%2Bfinal.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"1781\" data-original-width=\"2048\" height=\"557\" src=\"https://1.bp.blogspot.com/-QrMUDarqUX4/YKUgD_oiD1I/AAAAAAAABg0/3HdCQBYz5gErf42PeUf0uJaffIHT66VcwCLcBGAsYHQ/w640-h557/WC%2BChrome%2Bblogpost%2Bfinal.png\" width=\"640\" /></a></div><br /><div><br /><br />Keeping a site’s RSS <a href=\"https://developers.google.com/search/blog/2014/10/best-practices-for-xml-sitemaps-rssatom\" target=\"_blank\">up-to-date</a> will ensure Chrome can provide the latest content to users with this experiment. We will provide more guidance to web publishers as we learn and evaluate whether this feature will graduate from an experiment to a broader rollout in Chrome. <br /><br />We welcome feedback from publishers, bloggers, creators, and citizens of the open web (like you!) on this experiment as we aim to build deeper engagement between users and web publishers in Chrome. You can also stay up-to-date and ask us questions via <a href=\"https://twitter.com/WebCreators\" target=\"_blank\">@WebCreators</a> on Twitter or via email to webcreators@google.com. As part of this year’s Google I/O, we’ll be hosting a Meet Up for web publishers, creators and developers who would like to learn more, ask questions and share feedback. You can <a href=\"https://events.google.com/io?lng=en\" target=\"_blank\">sign up for I/O</a> (free this year) and <a href=\"https://www.google.com/url?q=https://gdg.community.dev/events/details/google-io-community-lounge-meetups-presents-following-on-the-open-web-discussion-feedback/&amp;sa=D&amp;source=editors&amp;ust=1621437836496000&amp;usg=AOvVaw21OtSVY8MrF5KbwCBNO59i\" target=\"_blank\">register for the Following on the Open Web session</a>, being held on May 19 (today) at 11 AM PT.<div><br /></div><div>Posted by Janice Wong, Product Manager, Google Chrome</div></div>",
        "contentSnippet": "Today, people have many ways to keep up with their favorite websites, including subscribing to mailing lists, notifications and RSS. It’s a lot for any one person to manage, so we’re exploring how to simplify the experience of getting the latest and greatest from your favorite sites directly in Chrome, building on the open RSS web standard. Our vision is to help people build a direct connection with their favorite publishers and creators on the web.\nIn the coming weeks, some Android users in the US on Chrome Canary may see an experimental Follow feature designed to help people get the latest content from sites they follow. Our goal for this feature is to allow people to follow the websites they care about, from the large publishers to the small neighborhood blogs, by tapping a Follow button in Chrome. When websites publish content, users can see updates from sites they have followed in a new Following section on the New Tab page:\n\n\n\n\nKeeping a site’s RSS up-to-date will ensure Chrome can provide the latest content to users with this experiment. We will provide more guidance to web publishers as we learn and evaluate whether this feature will graduate from an experiment to a broader rollout in Chrome. \nWe welcome feedback from publishers, bloggers, creators, and citizens of the open web (like you!) on this experiment as we aim to build deeper engagement between users and web publishers in Chrome. You can also stay up-to-date and ask us questions via @WebCreators on Twitter or via email to webcreators@google.com. As part of this year’s Google I/O, we’ll be hosting a Meet Up for web publishers, creators and developers who would like to learn more, ask questions and share feedback. You can sign up for I/O (free this year) and register for the Following on the Open Web session, being held on May 19 (today) at 11 AM PT.\n\nPosted by Janice Wong, Product Manager, Google Chrome",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-5655993789980170140",
        "isoDate": "2021-05-19T15:01:00.000Z"
    },
    {
        "title": "Update on User-Agent String Reduction in Chrome",
        "link": "http://blog.chromium.org/2021/05/update-on-user-agent-string-reduction.html",
        "pubDate": "2021-05-19T11:00:00.001Z",
        "author": "Chromium Blog",
        "content": "<p><b>Updates</b></p><p></p><ul style=\"text-align: left;\"><li><b>September 14, 2021</b>:&nbsp;<a href=\"https://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-dates.html\" target=\"_blank\">Updated timeline and origin trial announced</a>.</li></ul><p></p><p>A little over a year ago <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/-2JIRNMWJ7s/m/yHe4tQNLCgAJ\" target=\"_blank\">we announced our plans</a> to reduce the granularity of information available from the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent\" target=\"_blank\">User-Agent string</a>, which is sent by default for every HTTP request. <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/-2JIRNMWJ7s/m/u-YzXjZ8BAAJ\" target=\"_blank\">Shortly after</a>, we made the decision to put this effort on pause so as not to create an additional migration burden on the web ecosystem in the early days of the COVID-19 pandemic. Since then, we’ve spent a lot of time gathering valuable feedback from the ecosystem, <a href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/dafizBGwWMw\" target=\"_blank\">proposing ergonomic improvements</a> to the <a href=\"https://web.dev/user-agent-client-hints/\" target=\"_blank\">User-Agent Client Hints API</a> (UA-CH)—our proposed replacement for content negotiation and detection—as well as <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=1149575#c2\" target=\"_blank\">making web compatibility fixes</a>.</p> <p>UA-CH is now shipping by default in Chrome (since M89). We’ve also started the roll-out of both Client Hints Reliability mechanisms (<a href=\"https://chromestatus.com/feature/5727177800679424\" target=\"_blank\">Critical-CH</a> &amp; <a href=\"https://chromestatus.com/feature/5555544540577792\" target=\"_blank\">ACCEPT_CH</a>) to address use cases where hints are needed on the first request. While we don’t yet have exact dates and milestones to announce for the planned User-Agent string reduction changes, we’re ready to resume our efforts on this front.  </p><p>That said, we feel it's important to proceed in a way that gives the ecosystem and developers sufficient time to test use cases, provide feedback, and <a href=\"https://web.dev/migrate-to-ua-ch\" target=\"_blank\">migrate to UA-CH where appropriate</a>, which is why <i>no User-Agent string changes will be coming to the stable channel of Chrome in 2021</i>.  Our intent with this post is to provide transparency into our thinking and roadmap early on so you can plan to adapt accordingly.</p> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">What is changing, and how?</span></h2> <p>We plan to gradually reduce, <a href=\"https://www.chromium.org/updates/ua-reduction\" target=\"_blank\">in a phased manner</a>, the granularity of available information in the <span style=\"font-family: courier;\">User-Agent</span> header field, as well as the <span style=\"font-family: courier;\">navigator.userAgent</span>, <span style=\"font-family: courier;\">navigator.appVersion</span>, and <span style=\"font-family: courier;\">navigator.platform</span> JS APIs.</p> <p>Once this is complete, you will still be able to reliably get the <b>browser major version</b>, <b>platform name</b>, and distinguish <b>between desktop and mobile</b> (or tablet), solely from the User-Agent string. For more advanced use cases, you should migrate to the <a href=\"https://web.dev/user-agent-client-hints/\" target=\"_blank\">User Agent Client Hints API</a>.</p> <p>Note: We have no plans to change the User-Agent string on Android WebView or Chrome for iOS at this time, but will make public updates if and when that changes.</p> <p>Our current high-level plan is as follows:</p> <p></p><ul style=\"text-align: left;\"><li>Beginning in M92, we plan to start sending deprecation notices for the <span style=\"font-family: courier;\">navigator.userAgent</span>, <span style=\"font-family: courier;\">navigator.appVersion</span>, and <span style=\"font-family: courier;\">navigator.platform</span> getters in the <a href=\"https://developer.chrome.com/docs/devtools/issues/\" target=\"_blank\">DevTools Issues tab</a>.</li><li>In the coming weeks, we will announce an Origin Trial for sites to opt in to receiving the fully reduced User-Agent. We expect to run the Origin Trial for at least 6 months to provide enough time for sites to opt in, test, and provide feedback on the feasibility and compatibility of our desired end state.</li><li>We will evaluate feedback from Origin Trial partners and the community, and based on this feedback proceed to Phases 3 through 7 of our plan (see next section for details), giving the ecosystem adequate time to adapt in between them. Otherwise, depending on feedback we will reconsider the best course of action.</li><li>For sites with complex use cases that require more time for migration, we aim to offer the ability to extend the current User-Agent behavior for at least an additional 6 months (through a \"reverse Origin Trial\").</li></ul> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Proposed rollout plan</span></h2> <p>We plan to roll out these changes slowly and incrementally in 7 Phases—pending Origin Trial feedback—and plan to publish an update soon on the proposed timing and milestones beyond Phase 1.</p> <h3 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;\"><span style=\"background-color: transparent; color: #434343; font-family: Arial; font-size: 14pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;\">Reduction Preparation</span></h3> <p><b>Phase 1:</b> Warn about accessing <span style=\"font-family: courier;\">navigator.userAgent</span>, <span style=\"font-family: courier;\">navigator.appVersion</span>, and <span style=\"font-family: courier;\">navigator.platform</span> in DevTools, beginning in M92.</p> <p><b>Phase 2:</b> Launch an Origin Trial for sites to opt into the final reduced UA string for testing and feedback, for at least 6 months.</p> <h3 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;\"><span style=\"background-color: transparent; color: #434343; font-family: Arial; font-size: 14pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;\">Reduction Rollout</span></h3> <p><b>Phase 3:</b> Launch a reverse Origin Trial, for instances where a site may need more time for migration, for at least 6 months.</p> <p><b>Phase 4:</b> Ship reduced Chrome MINOR.BUILD.PATCH version numbers (“0.0.0”). Once rolled-out, the reduced UA string would apply to all page loads on desktop and mobile OSes that do not opt into the reverse Origin Trial.</p> <p><b>Phase 5:</b> Begin roll-out of reduced Desktop UA string and related JS APIs (<span style=\"font-family: courier;\">navigator.userAgent</span>, <span style=\"font-family: courier;\">navigator.appVersion</span>, <span style=\"font-family: courier;\">navigator.platform</span>). Once rolled-out, the reduced UA string would apply to all page loads on desktop OSes that do not opt into the reverse Origin Trial.</p> <p><b>Phase 6:</b> Begin roll-out of reduced Android Mobile (and Tablet) UA string and related JS APIs.  Once rolled-out, the reduced UA string would apply to all page loads on Android that do not opt into the reverse Origin Trial.</p> <h3 dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;\"><span style=\"background-color: transparent; color: #434343; font-family: Arial; font-size: 14pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;\">Reduction Completion</span></h3> <p><b>Phase 7:</b> reverse Origin Trial ends and all page loads receive the reduced UA string and related JS APIs.</p> <p>See the companion <a href=\"http://chromium.org/updates/ua-reduction\" target=\"_blank\">Reduced User Agent string updates page</a> for more details and example User Agent strings at each of these phases.</p> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">What do I need to do to get ready as a developer?</span></h2><p>Our plan was designed with backwards compatibility in mind, and while any changes to the User Agent string need to be managed carefully, we expect minimal friction for developers as we roll this out (i.e., existing parsers should continue to operate as expected).</p> <p>If your site, service, library or application relies on certain bits of information being present in the User Agent string such as <b>Chrome minor version</b>, <b>OS version number</b>, or <b>Android device model</b>, you will need to begin the migration to use the <a href=\"https://web.dev/user-agent-client-hints/\" target=\"_blank\">User Agent Client Hints API</a> instead.</p> <p>If you don’t require any of these, then no changes are required and things should continue to operate as they have to date.</p> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Why are we doing this?</span></h2><p>As noted in the <a href=\"https://github.com/WICG/ua-client-hints#explainer-reducing-user-agent-granularity\" target=\"_blank\">User Agent Client Hints explainer</a>, the User Agent string presents challenges for two reasons. Firstly, it <a href=\"https://w3c.github.io/fingerprinting-guidance/#passive\" target=\"_blank\">passively exposes</a> quite a lot of information about the browser for every HTTP request that <a href=\"https://www.w3.org/2001/tag/doc/unsanctioned-tracking/#unsanctioned-tracking-tracking-without-user-control\" target=\"_blank\">may be used for fingerprinting</a>. Secondly, it has grown in length and complexity over the years and encourages error-prone string parsing. We believe the <a href=\"https://wicg.github.io/ua-client-hints/\" target=\"_blank\">User Agent Client Hints API</a> solves both of these problems in a more developer- and user-friendly manner.</p> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">What about other browsers?</span></h2><p>In some ways Chrome is playing catch up on this front: Safari was the first to <a href=\"https://bugs.webkit.org/show_bug.cgi?id=216593\" target=\"_blank\">cap the macOS version number</a> in the UA string and <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1679929\" target=\"_blank\">Firefox has followed suit</a>. Firefox has also <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1693295\" target=\"_blank\">capped the Windows version number to 10.</a></p> <h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Learn More</span></h2> <p></p><ul style=\"text-align: left;\"><li><a href=\"https://web.dev/user-agent-client-hints/\" target=\"_blank\">Improving user privacy and developer experience with User-Agent Client Hints</a></li><li><a href=\"https://web.dev/migrate-to-ua-ch\" target=\"_blank\">Migrate to UA-CH</a></li></ul> <span class=\"post-author\">Posted by Mike Taylor and Jade Kessler, Chrome Team</span><p></p>",
        "contentSnippet": "Updates\n\n\nSeptember 14, 2021: Updated timeline and origin trial announced.\n\n\nA little over a year ago we announced our plans to reduce the granularity of information available from the User-Agent string, which is sent by default for every HTTP request. Shortly after, we made the decision to put this effort on pause so as not to create an additional migration burden on the web ecosystem in the early days of the COVID-19 pandemic. Since then, we’ve spent a lot of time gathering valuable feedback from the ecosystem, proposing ergonomic improvements to the User-Agent Client Hints API (UA-CH)—our proposed replacement for content negotiation and detection—as well as making web compatibility fixes.\n UA-CH is now shipping by default in Chrome (since M89). We’ve also started the roll-out of both Client Hints Reliability mechanisms (Critical-CH & ACCEPT_CH) to address use cases where hints are needed on the first request. While we don’t yet have exact dates and milestones to announce for the planned User-Agent string reduction changes, we’re ready to resume our efforts on this front.  \nThat said, we feel it's important to proceed in a way that gives the ecosystem and developers sufficient time to test use cases, provide feedback, and migrate to UA-CH where appropriate, which is why no User-Agent string changes will be coming to the stable channel of Chrome in 2021.  Our intent with this post is to provide transparency into our thinking and roadmap early on so you can plan to adapt accordingly.\n What is changing, and how?\n We plan to gradually reduce, in a phased manner, the granularity of available information in the User-Agent header field, as well as the navigator.userAgent, navigator.appVersion, and navigator.platform JS APIs.\n Once this is complete, you will still be able to reliably get the browser major version, platform name, and distinguish between desktop and mobile (or tablet), solely from the User-Agent string. For more advanced use cases, you should migrate to the User Agent Client Hints API.\n Note: We have no plans to change the User-Agent string on Android WebView or Chrome for iOS at this time, but will make public updates if and when that changes.\n Our current high-level plan is as follows:\n \n\nBeginning in M92, we plan to start sending deprecation notices for the navigator.userAgent, navigator.appVersion, and navigator.platform getters in the DevTools Issues tab.\nIn the coming weeks, we will announce an Origin Trial for sites to opt in to receiving the fully reduced User-Agent. We expect to run the Origin Trial for at least 6 months to provide enough time for sites to opt in, test, and provide feedback on the feasibility and compatibility of our desired end state.\nWe will evaluate feedback from Origin Trial partners and the community, and based on this feedback proceed to Phases 3 through 7 of our plan (see next section for details), giving the ecosystem adequate time to adapt in between them. Otherwise, depending on feedback we will reconsider the best course of action.\nFor sites with complex use cases that require more time for migration, we aim to offer the ability to extend the current User-Agent behavior for at least an additional 6 months (through a \"reverse Origin Trial\").\n \nProposed rollout plan\n We plan to roll out these changes slowly and incrementally in 7 Phases—pending Origin Trial feedback—and plan to publish an update soon on the proposed timing and milestones beyond Phase 1.\n Reduction Preparation\n Phase 1: Warn about accessing navigator.userAgent, navigator.appVersion, and navigator.platform in DevTools, beginning in M92.\n Phase 2: Launch an Origin Trial for sites to opt into the final reduced UA string for testing and feedback, for at least 6 months.\n Reduction Rollout\n Phase 3: Launch a reverse Origin Trial, for instances where a site may need more time for migration, for at least 6 months.\n Phase 4: Ship reduced Chrome MINOR.BUILD.PATCH version numbers (“0.0.0”). Once rolled-out, the reduced UA string would apply to all page loads on desktop and mobile OSes that do not opt into the reverse Origin Trial.\n Phase 5: Begin roll-out of reduced Desktop UA string and related JS APIs (navigator.userAgent, navigator.appVersion, navigator.platform). Once rolled-out, the reduced UA string would apply to all page loads on desktop OSes that do not opt into the reverse Origin Trial.\n Phase 6: Begin roll-out of reduced Android Mobile (and Tablet) UA string and related JS APIs.  Once rolled-out, the reduced UA string would apply to all page loads on Android that do not opt into the reverse Origin Trial.\n Reduction Completion\n Phase 7: reverse Origin Trial ends and all page loads receive the reduced UA string and related JS APIs.\n See the companion Reduced User Agent string updates page for more details and example User Agent strings at each of these phases.\n What do I need to do to get ready as a developer?\nOur plan was designed with backwards compatibility in mind, and while any changes to the User Agent string need to be managed carefully, we expect minimal friction for developers as we roll this out (i.e., existing parsers should continue to operate as expected).\n If your site, service, library or application relies on certain bits of information being present in the User Agent string such as Chrome minor version, OS version number, or Android device model, you will need to begin the migration to use the User Agent Client Hints API instead.\n If you don’t require any of these, then no changes are required and things should continue to operate as they have to date.\n Why are we doing this?\nAs noted in the User Agent Client Hints explainer, the User Agent string presents challenges for two reasons. Firstly, it passively exposes quite a lot of information about the browser for every HTTP request that may be used for fingerprinting. Secondly, it has grown in length and complexity over the years and encourages error-prone string parsing. We believe the User Agent Client Hints API solves both of these problems in a more developer- and user-friendly manner.\n What about other browsers?\nIn some ways Chrome is playing catch up on this front: Safari was the first to cap the macOS version number in the UA string and Firefox has followed suit. Firefox has also capped the Windows version number to 10.\n Learn More\n \n\nImproving user privacy and developer experience with User-Agent Client Hints\nMigrate to UA-CH\n Posted by Mike Taylor and Jade Kessler, Chrome Team",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-7827756717507590999",
        "isoDate": "2021-05-19T11:00:00.001Z"
    },
    {
        "title": "Adjusted timeline for SharedArrayBuffers",
        "link": "http://blog.chromium.org/2021/05/adjusted-timeline-for-sharedarraybuffers.html",
        "pubDate": "2021-05-10T16:00:00.000Z",
        "author": "Chromium Blog",
        "content": "<p>Back in February, we <a href=\"https://blog.chromium.org/2021/02/restriction-on-sharedarraybuffers.html\" target=\"_blank\">announced</a> that <a href=\"https://developer.chrome.com/blog/enabling-shared-array-buffer/#cross-origin-isolation\" target=\"_blank\">cross-origin isolation</a> will be required on all platforms in order to access APIs like <span style=\"font-family: courier;\">SharedArrayBuffer</span> and <a href=\"https://web.dev/monitor-total-page-memory-usage/\" target=\"_blank\">performance.measureUserAgentSpecificMemory()</a> starting in Chrome 91. Based on your feedback and issues reported, we've decided to adjust the timeline for <span style=\"font-family: courier;\">SharedArrayBuffer</span> usage in none cross-origin isolated sites to be restricted in Chrome 92.</p> <p>Your feedback is important and we are listening.</p> <span class=\"post-author\">Posted by Lutz Vahl, Technical Program Manager</span>",
        "contentSnippet": "Back in February, we announced that cross-origin isolation will be required on all platforms in order to access APIs like SharedArrayBuffer and performance.measureUserAgentSpecificMemory() starting in Chrome 91. Based on your feedback and issues reported, we've decided to adjust the timeline for SharedArrayBuffer usage in none cross-origin isolated sites to be restricted in Chrome 92.\n Your feedback is important and we are listening.\n Posted by Lutz Vahl, Technical Program Manager",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-5986837495320034538",
        "isoDate": "2021-05-10T16:00:00.000Z"
    },
    {
        "title": "Chrome 91: Handwriting Recognition, WebXR Plane Detection and More",
        "link": "http://blog.chromium.org/2021/04/chrome-91-handwriting-recognition-webxr.html",
        "pubDate": "2021-04-22T21:46:00.010Z",
        "author": "Chromium Blog",
        "content": " <p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D76\">ChromeStatus.com</a>. Chrome 91 is beta as of April 22, 2021.</p> <h2>Origin Trials</h2><p>This version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h3>New Origin Trials</h3> <h4>Declarative Link Capturing for PWAs</h4><p>The new Web App Manifest member called <code>capture_links</code> controls what happens when the user navigates to a page within scope of an installed web app. It allows sites to automatically open a new PWA window when the user clicks a link to their app or to have a single window mode like mobile apps. <a href=\"https://developer.chrome.com/origintrials/#/view_trial/4285175045443026945\">Sign up for the origin trial</a> and learn more on the origin trial dashboard.</p> <h4>WebTransport</h4><p>WebTransport is a protocol framework that enables clients constrained by the Web security model to communicate with a remote server using a secure multiplexed transport.</p> <p>Currently, Web application developers have two APIs for bidirectional communications with a remote server: <code>WebSockets</code> and <code>RTCDataChannel</code>.  <code>WebSockets</code> are TCP-based, thus having all of the drawbacks of TCP (head of line blocking, lack of support for unreliable data transport) that make it a poor fit for latency-sensitive applications.  <code>RTCDataChannel</code> is based on the Stream Control Transmission Protocol (SCTP), which does not have these drawbacks; however, it is designed to be used in a peer-to-peer context, which causes its use in client-server settings to be fairly low.  <code>WebTransport</code> provides a client-server API that supports bidirectional transfer of both unreliable and reliable data, using UDP-like datagrams and cancellable streams. <code>WebTransport</code> calls are visible in the Network panel of DevTools and identified as such in the Type column. </p> <p>For more information, see <a href=\"https://web.dev/webtransport/\">Experimenting with WebTransport</a>. <a href=\"https://www.google.com/url?q=https://developer.chrome.com/origintrials/%23/view_trial/793759434324049921&amp;sa=D&amp;source=editors&amp;ust=1619104452220000&amp;usg=AOvVaw2ge7dt3GG_6ucYabUaGf_l\">Sign up for the origin trial</a> and learn more on the origin trial dashboard.</p> <h4>WebXR Plane Detection API</h4><p>WebXR applications can now retrieve data about planes (flat surfaces) in the user's environment, allowing better user experiences with less processing power. Without this feature plane detection requires custom computer vision algorithms using data from <code>MediaDevices.getUserMedia()</code>. These solutions usually fall short of quality and accuracy expectations for AR experiences and don't support world scale. <a href=\"https://developer.chrome.com/origintrials/#/view_trial/1154047404513689601\">Sign up for the origin tria</a>l and learn more on the dashboard.</p> <h3>Completed Origin Trials</h3><p>The following features, previously in a Chrome origin trial, are now enabled by default.</p> <h4>WebAssembly SIMD</h4><p>WebAssembly SIMD exposes hardware SIMD instructions to WebAssembly applications in a platform-independent way. This introduces a new 128-bit type that can represent different types of packed data, and several vector operations that work on packed data. SIMD can boost performance by exploiting data level parallelism and is also useful when compiling native code to WebAssembly. For more information, see the V8 feature explainer for<a href=\"https://v8.dev/features/simd\"> WebAssembly SIMD</a>.</p> <h2>Other features in this release</h2> <h3>Align performance API timer resolution to cross-origin isolated capability</h3><p>Coarsening of <code>performance.now()</code> and related timestamps based on site isolation status is <a href=\"https://developer.chrome.com/blog/cross-origin-isolated-hr-timers\">now consistent across platforms</a>. This decreases the resolution on desktop from 5 microseconds to 100 microseconds in non-isolated contexts. It also increases their resolution on Android from 100 microseconds to 5 microseconds in cross-origin isolated contexts, where it's safe to do so.</p> <h3>Clipboard: Read-Only Files Support</h3><p>On desktop, apps can now <a href=\"https://www.chromestatus.com/features/5671807392677888\">read files from the clipboard</a> (but not write files to the clipboard). For files on the clipboard, apps have read-only access.</p> <pre>async function onPaste(e) {<br />  let file = e.clipboardData.files[0];<br />  let contents = await file.text();  <br />}<br /></pre> <h3>CSS</h3> <h4>Custom Counter Styles</h4><p>The <a href=\"https://www.chromestatus.com/feature/5692693659254784\">CSS <code>@counter-style</code> rule</a> allows web authors to specify and use custom counter styles in list markers and CSS counters. This helps internationalization. This change implements all of the features in <a href=\"https://drafts.csswg.org/css-counter-styles-3\">CSS Counter Styles Level 3</a> except:</p> <ul><li>Image symbols, which no browsers support, and is 'at-risk' per the spec</li><li>The <code>speak-as</code> descriptor, which is an accessibility feature </li><li>The <code>symbols()</code> function.</li></ul> <h4>Single &lt;compound-selector&gt; for :host() and :host-context()</h4><p>The <code>:host()</code> and <code>:host-context()</code> pseudo-classes <a href=\"https://www.chromestatus.com/feature/5755183847964672\">now accept a single <code>&lt;compound-selector&gt;</code></a> in addition to a <code>&lt;compound-selector-list&gt;</code>.</p> <h3>Form Controls Visual Refresh on Android</h3><p>Form controls have a new, refreshed appearance, with better accessibility and touch support. This was a collaboration between Microsoft and Google, and if you'd like additional information, you can view a <a href=\"https://www.youtube.com/watch?v=ZFvPLrKZywA\">past CDS talk</a> or the <a href=\"https://blogs.windows.com/msedgedev/2019/10/15/form-controls-microsoft-edge-chromium/\">Microsoft's blog post</a>.</p> <p>In this release, we have brought the same form controls UX to Android as already launched on other platforms. The new form controls include automatically darkening form controls and scrollbars when in dark mode.</p> <p>Dark mode is an accessibility feature that allows web authors to enable their web pages to be viewed in dark mode. When enabled, users are able to view dark mode supported websites by toggling the dark mode settings on their Android devices. dark mode is easier on the eyes in a low light environment and lowers battery consumption.</p> <h3>GravitySensor Interface</h3><p>The <code>GravitySensor</code> interface provides <a href=\"https://www.chromestatus.com/feature/5384099747332096\">a three-axis reading of the gravity force</a>. It's already possible to derive readings close to those provided by this interface removing the <code>LinerAccelerometer</code> reading from the <code>Accelerometer</code> reading.</p> <h3>Suggested file name and location for the File System Access API</h3><p>When using the File System Access API, web apps can now <a href=\"https://www.chromestatus.com/feature/6013006146174976\">suggest the name and location of a file or directory</a> that is being created or loaded. This provides a better user experience and brings web apps closer to the behavior of system apps. For more about the File System Access API, see <a href=\"https://web.dev/file-system-access/\">The File System Access API: simplifying access to local files</a>.</p> <h3>WebOTP API: cross-origin iframe support</h3><p>The WebOTP API is now <a href=\"https://web.dev/web-otp-iframe\">usable in cross-origin iframes</a> when enabled by a permission policy. The WebOTP API gives developers the ability to programmatically read one time codes from specially-formatted SMS messages addressed to their origin to reduce user friction. Many sites embed iframes that handle authentication.</p> <h3>WebSockets over HTTP/2</h3><p>Chrome supports <a href=\"https://www.chromestatus.com/feature/6251293127475200\">WebSockets over HTTP/2</a> in Chromium as specified in <a href=\"https://tools.ietf.org/html/rfc8441\">RFC 8441</a>. This is only used for secure WebSockets requests, and only when there is already an HTTP/2 connection where the server has already advertised support for WebSockets over HTTP/2 via the HTTP/2 SETTINGS parameter defined in the specification.</p> <h3>Credentials sharing for sites affiliated with Digital Asset Links</h3><p>Since 2015 developers have used Digital Asset Links (DALs) to associate Android apps with websites to assist users with logging in. If you employ multiple domains that share the same account management backend, you can now also associate them with one another to enable users to <a href=\"https://developer.chrome.com/blog/site-affiliation/\">save credentials once and have the Chrome password manager suggest them to any of the affiliated websites</a>. For more information, see <a href=\"https://developer.chrome.com/blog/site-affiliation/\">Enable Chrome to share login credentials across affiliated sites</a>.</p> <h2>JavaScript</h2><p>This version of Chrome incorporates version 9.1 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h3>ES Modules for service workers ('module' type option)</h3><p>JavaScript now supports <a href=\"https://www.chromestatus.com/feature/4609574738853888\">modules in service workers</a>. Setting <code>'module'</code> type by the constructor's type attribute, worker scripts are loaded as ES modules and the <code>import</code> statement is available on worker contexts. With this feature, web developers can more easily write programs in a composable way and share them among a page and workers.</p> <h3>Checks for Private Fields</h3><p>Developers can now<a href=\"https://www.chromestatus.com/feature/5006138707804160\"> test for the existence of private fields</a> in an object using the syntax <code>#foo in obj</code>.</p> <h2>Deprecations, and Removals</h2><p>This version of Chrome introduces the deprecation listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h3 style=\"text-align: left;\"><span style=\"font-size: 18.72px;\">Remove alert(), confirm(), and prompt() for Cross Origin iframes</span></h3> <p>Chrome allows iframes to trigger Javascript dialogs. For example it shows “&lt;URL&gt; says ...” when the iframe is the same origin as the top frame, and “An embedded page on this page says...” when the iframe is cross-origin. This is confusing, and has led to spoofs where sites pretend the message comes from Chrome or a different website.&nbsp;</p><p>Chrome 91 deprecates this ability.&nbsp;<a href=\"https://chromestatus.com/feature/5148698084376576\">Removing support</a> for cross origin iframes’ ability to call <code>alert()</code>, <code>confirm()</code>, and <code>prompt()</code> will prevent this kind of spoofing, and unblock further UI simplifications. For example, this means notexample.com will no longer be able to call <code>window.alert()</code>, <code>window.prompt()</code>, or <code>window.confirm()</code> if embedded in an iframe on example.com.</p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 91 is beta as of April 22, 2021.\n Origin Trials\nThis version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n Declarative Link Capturing for PWAs\nThe new Web App Manifest member called capture_links controls what happens when the user navigates to a page within scope of an installed web app. It allows sites to automatically open a new PWA window when the user clicks a link to their app or to have a single window mode like mobile apps. Sign up for the origin trial and learn more on the origin trial dashboard.\n WebTransport\nWebTransport is a protocol framework that enables clients constrained by the Web security model to communicate with a remote server using a secure multiplexed transport.\n Currently, Web application developers have two APIs for bidirectional communications with a remote server: WebSockets and RTCDataChannel.  WebSockets are TCP-based, thus having all of the drawbacks of TCP (head of line blocking, lack of support for unreliable data transport) that make it a poor fit for latency-sensitive applications.  RTCDataChannel is based on the Stream Control Transmission Protocol (SCTP), which does not have these drawbacks; however, it is designed to be used in a peer-to-peer context, which causes its use in client-server settings to be fairly low.  WebTransport provides a client-server API that supports bidirectional transfer of both unreliable and reliable data, using UDP-like datagrams and cancellable streams. WebTransport calls are visible in the Network panel of DevTools and identified as such in the Type column. \n For more information, see Experimenting with WebTransport. Sign up for the origin trial and learn more on the origin trial dashboard.\n WebXR Plane Detection API\nWebXR applications can now retrieve data about planes (flat surfaces) in the user's environment, allowing better user experiences with less processing power. Without this feature plane detection requires custom computer vision algorithms using data from MediaDevices.getUserMedia(). These solutions usually fall short of quality and accuracy expectations for AR experiences and don't support world scale. Sign up for the origin trial and learn more on the dashboard.\n Completed Origin Trials\nThe following features, previously in a Chrome origin trial, are now enabled by default.\n WebAssembly SIMD\nWebAssembly SIMD exposes hardware SIMD instructions to WebAssembly applications in a platform-independent way. This introduces a new 128-bit type that can represent different types of packed data, and several vector operations that work on packed data. SIMD can boost performance by exploiting data level parallelism and is also useful when compiling native code to WebAssembly. For more information, see the V8 feature explainer for WebAssembly SIMD.\n Other features in this release\n Align performance API timer resolution to cross-origin isolated capability\nCoarsening of performance.now() and related timestamps based on site isolation status is now consistent across platforms. This decreases the resolution on desktop from 5 microseconds to 100 microseconds in non-isolated contexts. It also increases their resolution on Android from 100 microseconds to 5 microseconds in cross-origin isolated contexts, where it's safe to do so.\n Clipboard: Read-Only Files Support\nOn desktop, apps can now read files from the clipboard (but not write files to the clipboard). For files on the clipboard, apps have read-only access.\n async function onPaste(e) {\n  let file = e.clipboardData.files[0];\n  let contents = await file.text();  \n}\n CSS\n Custom Counter Styles\nThe CSS @counter-style rule allows web authors to specify and use custom counter styles in list markers and CSS counters. This helps internationalization. This change implements all of the features in CSS Counter Styles Level 3 except:\n \nImage symbols, which no browsers support, and is 'at-risk' per the spec\nThe speak-as descriptor, which is an accessibility feature \nThe symbols() function.\n \nSingle <compound-selector> for :host() and :host-context()\nThe :host() and :host-context() pseudo-classes now accept a single <compound-selector> in addition to a <compound-selector-list>.\n Form Controls Visual Refresh on Android\nForm controls have a new, refreshed appearance, with better accessibility and touch support. This was a collaboration between Microsoft and Google, and if you'd like additional information, you can view a past CDS talk or the Microsoft's blog post.\n In this release, we have brought the same form controls UX to Android as already launched on other platforms. The new form controls include automatically darkening form controls and scrollbars when in dark mode.\n Dark mode is an accessibility feature that allows web authors to enable their web pages to be viewed in dark mode. When enabled, users are able to view dark mode supported websites by toggling the dark mode settings on their Android devices. dark mode is easier on the eyes in a low light environment and lowers battery consumption.\n GravitySensor Interface\nThe GravitySensor interface provides a three-axis reading of the gravity force. It's already possible to derive readings close to those provided by this interface removing the LinerAccelerometer reading from the Accelerometer reading.\n Suggested file name and location for the File System Access API\nWhen using the File System Access API, web apps can now suggest the name and location of a file or directory that is being created or loaded. This provides a better user experience and brings web apps closer to the behavior of system apps. For more about the File System Access API, see The File System Access API: simplifying access to local files.\n WebOTP API: cross-origin iframe support\nThe WebOTP API is now usable in cross-origin iframes when enabled by a permission policy. The WebOTP API gives developers the ability to programmatically read one time codes from specially-formatted SMS messages addressed to their origin to reduce user friction. Many sites embed iframes that handle authentication.\n WebSockets over HTTP/2\nChrome supports WebSockets over HTTP/2 in Chromium as specified in RFC 8441. This is only used for secure WebSockets requests, and only when there is already an HTTP/2 connection where the server has already advertised support for WebSockets over HTTP/2 via the HTTP/2 SETTINGS parameter defined in the specification.\n Credentials sharing for sites affiliated with Digital Asset Links\nSince 2015 developers have used Digital Asset Links (DALs) to associate Android apps with websites to assist users with logging in. If you employ multiple domains that share the same account management backend, you can now also associate them with one another to enable users to save credentials once and have the Chrome password manager suggest them to any of the affiliated websites. For more information, see Enable Chrome to share login credentials across affiliated sites.\n JavaScript\nThis version of Chrome incorporates version 9.1 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete list of recent features in the V8 release notes.\n ES Modules for service workers ('module' type option)\nJavaScript now supports modules in service workers. Setting 'module' type by the constructor's type attribute, worker scripts are loaded as ES modules and the import statement is available on worker contexts. With this feature, web developers can more easily write programs in a composable way and share them among a page and workers.\n Checks for Private Fields\nDevelopers can now test for the existence of private fields in an object using the syntax #foo in obj.\n Deprecations, and Removals\nThis version of Chrome introduces the deprecation listed below. Visit ChromeStatus.com for lists of previous removals.\n Remove alert(), confirm(), and prompt() for Cross Origin iframes\n Chrome allows iframes to trigger Javascript dialogs. For example it shows “<URL> says ...” when the iframe is the same origin as the top frame, and “An embedded page on this page says...” when the iframe is cross-origin. This is confusing, and has led to spoofs where sites pretend the message comes from Chrome or a different website. \nChrome 91 deprecates this ability. Removing support for cross origin iframes’ ability to call alert(), confirm(), and prompt() will prevent this kind of spoofing, and unblock further UI simplifications. For example, this means notexample.com will no longer be able to call window.alert(), window.prompt(), or window.confirm() if embedded in an iframe on example.com.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-83084614319231284",
        "isoDate": "2021-04-22T21:46:00.010Z"
    },
    {
        "title": "Digging for performance gold: finding hidden performance wins",
        "link": "http://blog.chromium.org/2021/04/digging-for-performance-gold.html",
        "pubDate": "2021-04-22T19:15:00.001Z",
        "author": "Chromium Blog",
        "content": "<i>We are fortunate that so many people choose Chrome as their browser to get things done, which is why we are continually investing in making Chrome more performant. But with software as complex as Chrome, there is a lot of performance left hidden in areas we aren’t actively working on. In our latest post in the <a href=\"https://blog.chromium.org/search/label/the%20fast%20and%20the%20curious\">The Fast and the Curious</a> series, we investigate how to diagnose, find, and fix performance problems that normally go undetected.</i><br /><br /><br /><br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">The 1%</span></h2>Our metrics show that while Chrome is fast on average, it can be noticeably slow at times. Such user-pain is visible in the 99th percentile of many of our metrics but unreproducible, and thus quite hard to act upon. Deeper analysis in the data shows that the long-tail of performance is not 1% of users on slow machines but rather many users, 1% of the time.<br /><br />Let’s talk about 1%. 1% is quite large in practice. The core metric we use is “jank” which is a noticeable delay between when the user gives input and when software reacts to it. Chrome measures jank every 30 seconds, so Jank in 1% of samples for a given user means jank once every 50 minutes. To that user, Chrome feels slow at those moments. Now the problem: can we find and fix the root causes of all the ways Chrome can be momentarily slow for our users?<br /><br /><div><br /></div><div><br /></div><div><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">Approach</span></h2>As engineers, our training in optimization is to focus on improving the algorithmic performance of the components we own. The last 3 years of analyzing the immensely complex codebase of Chrome however have taught us that the real issue is often cross-cutting: multiple unrelated features’ long-tail performance issues, sharing the same systemic root cause(s). Applying local expertise and optimization is likely to miss the global optimum. It is necessary to disregard our initial intuition and assume ignorance, forcing us to dig beyond what is immediately apparent and find the underlying root cause by relentlessly exposing what we don’t know.</div><div><br /></div><div><br /></div><div><br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">Chasing Invisible Bugs</span></h2>How do we find bugs that are unforeseen, unreproducible, unowned, and essentially invisible?<br /><br />First, define a scenario. For this work, we focus on user-visible Jank, which we <a href=\"https://chromium.googlesource.com/chromium/src/+/master/tools/metrics/histograms/README.md\">measure in the field</a> as a way to systematically identify moments where Chrome feels slow.<br /><br />Second, gather high actionability bug reports in the field. For this we rely on Chrome’s <a href=\"https://source.chromium.org/search?q=BackgroundTracing&amp;ss=chromium\">BackgroundTracing</a> infrastructure to generate what we call Slow Reports. A subset of Canary users who have opted in to sharing anonymized metrics have circular-buffer tracing enabled to examine specific scenarios. If a preconfigured threshold on a metric of interest is hit, the trace buffer is captured, anonymized, and uploaded to Google servers.<br /><br />Such a bug report might look like this:</div><div><br /></div><div><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-dsEYPR28V8k/YIHSXrkX-iI/AAAAAAAABeg/q_X7Q_uRJIw7LXhqszlW97mnckb71ZumQCLcBGAsYHQ/s1351/image1.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"190\" data-original-width=\"1351\" height=\"92\" src=\"https://1.bp.blogspot.com/-dsEYPR28V8k/YIHSXrkX-iI/AAAAAAAABeg/q_X7Q_uRJIw7LXhqszlW97mnckb71ZumQCLcBGAsYHQ/w654-h92/image1.png\" width=\"654\" /></a></div><span style=\"font-size: xx-small;\"><div style=\"text-align: center;\">chrome://tracing view of a 2 seconds Jank on AutocompleteController::UpdateResult() on an otherwise healthy machine</div></span><br /><br />We have a culprit! Let’s optimize AutocompleteController? No! We don’t know why yet: keep assuming ignorance!<br /><br />By augmenting BackgroundTracing with stack sampling, we were able to find a recurring stack under stalled AutoComplete events:</div><div><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><br /></span></div><div><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>RegEnumValueW</span></div><div><span id=\"docs-internal-guid-4a961e85-7fff-418a-ea39-3b655b9b59f5\"><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>RegEnumValueWStub</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>base::win::RegistryValueIterator::Read()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::`anonymous namespace\\'::CachedFontLinkSettings::GetLinkedFonts</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::internal::LinkedFontsIterator::GetLinkedFonts()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::internal::LinkedFontsIterator::NextFont(gfx::Font *)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::GetFallbackFonts(gfx::Font const &amp;)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::ShapeRuns(...)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::ItemizeAndShapeText(...)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::EnsureLayoutRunList()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::EnsureLayout()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::GetStringSizeF()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>gfx::RenderTextHarfBuzz::GetStringSize()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxTextView::CalculatePreferredSize()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxTextView::ReapplyStyling()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxTextView::SetText...)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxResultView::Invalidate()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxResultView::SetMatch(AutocompleteMatch const &amp;)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxPopupContentsView::UpdatePopupAppearance()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxPopupModel::OnResultChanged()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxEditModel::OnCurrentMatchChanged()</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>OmniboxController::OnResultChanged(bool)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>AutocompleteController::UpdateResult(bool,bool)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>AutocompleteController::Start(AutocompleteInput const &amp;)</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: inherit; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span>&nbsp;&nbsp; &nbsp;</span>(...)</span></p><div><br /></div></span></div><div>Ah ha! Autocomplete is not at fault. Time to optimize GetFallbackFonts()?! But wait… Why is GetFallbackFonts() even called in the first place?<br /><br />And before we figure that out, how do we know this is the #1 root cause of our overall long-tail performance issue? We’ve only looked at one trace so far after all...</div><div><br /></div><div><br /></div><div><br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">The Measurement Conundrum</span></h2>The metrics tell us how many users are affected and how bad it is, but they do not highlight the root cause.<br /><br />Slow Reports tell us what the problem is for a specific user but not how many users are affected. And while we can query our corpus of Slow Report traces, it comes with inherent biases that make it impossible to correlate 1:1 with metrics. For instance, because Chrome only reports the first instance of bad performance per-session and only for users of the Canary/Dev channel, there’s both a startup and a population bias.<br /><br />This is the measurement conundrum. The more actionability (data) a tool provides, the fewer scenarios it captures and the more bias it incurs. Depth vs. breadth.<br /><br />Tools that attempt to do both sit somewhere in the middle, where they use aggregation over a large dataset and risk showing aggregate results based on flawed input (e.g. circular buffer tracing having dropped the interesting portion and contributing to a biased aggregate).<br /><br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-m5ibSfIRpcA/YIHSpVOc_EI/AAAAAAAABeo/cKFRR2k0Y8YQWArGmJIwLA8aYb56xB4UwCLcBGAsYHQ/s1140/image4.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"702\" data-original-width=\"1140\" height=\"334\" src=\"https://1.bp.blogspot.com/-m5ibSfIRpcA/YIHSpVOc_EI/AAAAAAAABeo/cKFRR2k0Y8YQWArGmJIwLA8aYb56xB4UwCLcBGAsYHQ/w542-h334/image4.png\" width=\"542\" /></a></div><div style=\"text-align: center;\"><br /></div><br /><br />Thus we scientifically opted for the least engineering-minded option: open a bunch of Slow Report traces manually. This gave us the most actionability over a top-level issue we’d already quantified.<br /><br />After opening dozens of traces it turned out that a great majority showed variations of the aforementioned fonts issue. While this didn’t give us a precise #users-affected, it was enough for us to believe it was the main cause of user pain seen in the metrics.</div><div><br /></div><div><br /></div><div><br /></div><div><br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">Fallback Fonts</span></h2>We dug into why GetFallbackFonts() had to be called in the first place. In the example above, the caller is trying to determine the size in pixels of a Unicode string rendered by a given font.<br /><br />If a substring within it is from a <a href=\"https://en.wikipedia.org/wiki/Unicode_block\">Unicode Block</a> that can’t be rendered by the given font, GetFallbackFont() is used to request the system recommended fallback font for it. If that fails, GetFallbackFonts() is invoked to try all the <a href=\"https://docs.microsoft.com/en-us/globalization/input/font-technology\">linked fonts</a> and determine the one that can best render it; that second fallback is much slower.<br /><br />GetFallbackFont() should never fail, but in practice it’s not that simple. The reliable way to do this on Windows is to query <a href=\"https://docs.microsoft.com/en-us/windows/win32/directwrite/introducing-directwrite\">DirectWrite</a>; however, DirectWrite was added in Windows 7, when Chrome still supported Windows XP. Therefore the GetFallbackFont() logic was forced to stick to a less reliable <a href=\"https://chromium.googlesource.com/chromium/src/+/22aed04422b04b2cf04f7b7d61392da4e9a2c85a/ui/gfx/font_fallback_win.cc#303\">heuristic using Uniscribe+GDI</a> in order to work on both versions of the OS. Since things worked most of the time, no one noticed that this could have been cleaned up when Chrome later dropped support for Windows XP. With new tooling to investigate long-tail performance, this turned out to be the number one cause of jank (unnecessarily invoking GetFallbackFonts()).<br /><br />We <a href=\"https://chromium-review.googlesource.com/c/chromium/src/+/1663504/\">fixed</a> that, reducing the amount of calls to GetFallbackFonts() by 4x.</div><div><br /></div><div><br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-3ENmUh4Iayw/YIHS7f03viI/AAAAAAAABew/KveSNIGZTesuDigmQ3E-yTerD_9g_z4hQCLcBGAsYHQ/s1244/image3.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"487\" data-original-width=\"1244\" height=\"258\" src=\"https://1.bp.blogspot.com/-3ENmUh4Iayw/YIHS7f03viI/AAAAAAAABew/KveSNIGZTesuDigmQ3E-yTerD_9g_z4hQCLcBGAsYHQ/w660-h258/image3.png\" width=\"660\" /></a></div><div style=\"text-align: center;\"><br /></div><br /><br />Still not zero though, and still seeing instances of the aforementioned AutoComplete issue in our Slow Reports. Keep digging. DirectWrite’s GetFallbackFont() failing was unexpected, but since Slow Reports are anonymized, no user-generated strings can be uploaded -- and therefore, finding which codepoints were problematic was tricky. We teamed up with our privacy experts to instrument Unicode Block and Script of text blocks going through <a href=\"https://en.wikipedia.org/wiki/HarfBuzz\">HarfBuzz</a> so that we could ensure no leakage of <a href=\"https://en.wikipedia.org/wiki/Personal_data\">Personally Identifiable Information</a>.</div><div><br /></div><div><br /></div><div>&nbsp; <br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">The Emoji Saga</span></h2>With this new recording enabled, the next wave of Slow Reports came back. The vast majority of reports indicated that font fallback was failing when DirectWrite was being asked to find a font for a codepoint (Unicode character) in <a href=\"https://www.compart.com/en/unicode/block/U+1F300\">Miscellaneous Symbols and Pictographs</a>. We wrote a local script trying all codepoints in that Unicode Block and quickly found out which ones could be problematic: U+1F3FB - U+1F3FF are modifiers added in Unicode 8.0 and are meaningful only when paired with another codepoint. For instance, U+1F9D7 (🧗) when paired with U+1F3FF is 🧗🏿. No font can render U+1F3FF on its own, and font fallback would correctly error out after scanning all linked fonts when asked to find one. The bug was in the browser-side Unicode <a href=\"https://unicode.org/reports/tr29/\">segmentation</a> logic which incorrectly broke down these two <a href=\"https://en.wikipedia.org/wiki/Code_point\">codepoints</a> and asked DirectWrite to render them separately instead of keeping them as a single grapheme.<br /><br />But wait, doesn’t Chrome support modern Unicode..?! Indeed, it does, in Blink which renders the web content. But the browser-side logic was not updated to support modern emojis (with modifiers) because it didn’t use to draw emojis at all. It’s only when the browser UI (tab strip, bookmark bar, omnibox, etc.) was modernized to support Unicode circa 2018 that the legacy segmentation logic became an (invisible) problem.<br /><br />On top of that, the caching logic did not cache on error, so trying to render a modifier on its own caused a massive jank, every time, for users with a lot of fonts installed. Ironically, this cache had been added to amortize the cost of this misunderstood bottleneck when Unicode support was first added to browser UI. Diving deeper into the underlying implementation of our fonts logic, rather than stopping at the layer of the fonts APIs, not only fixed a major performance issue but also resulted in a correctness fix for other <a href=\"https://emojipedia.org/emoji/\">emojis</a>. For instance, 🏳️‍🌈 is encoded as U+1F3F3( 🏳️) + U+1F308 (🌈); before the itemization fix, browser UI would incorrectly render this grapheme as 🏳️🌈.<br /><br /><br /><br /><h2 style=\"text-align: left;\"><span style=\"font-size: x-large;\">And the journey continues...</span></h2>Our journey keeps going into various components of Chrome but it always follows the same basic playbook: assume ignorance and relentlessly investigate unforeseen, unreproducible, and unowned bugs. And while stack ranking issues is nigh impossible (see: measurement conundrum), fixing the top 5 findings from any given tool and zooming in on the long tail has always addressed the majority of the user pain in practice.<br /><br />Using this approach, we have reduced user-visible jank by a factor of 10X over the last 2.5 years and improved long-tail performance of many features caught in the cross-fire. <br /><br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-NSiuJ2KAmyQ/YIHTGxjgvVI/AAAAAAAABe0/3QSd51szD3ok4zZZwwPVHGDIDCvyKA8rwCLcBGAsYHQ/s905/image5.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"489\" data-original-width=\"905\" height=\"347\" src=\"https://1.bp.blogspot.com/-NSiuJ2KAmyQ/YIHTGxjgvVI/AAAAAAAABe0/3QSd51szD3ok4zZZwwPVHGDIDCvyKA8rwCLcBGAsYHQ/w642-h347/image5.png\" width=\"642\" /></a></div><div style=\"text-align: center;\"><span style=\"font-size: xx-small;\">99th percentile of # of unresponsive 100ms intervals over a 30 seconds sample</span></div><div><br /></div><div><br /></div>Posted by Gabriel Charette 🤸🏼 and Etienne Bergeron 🕵🏻, Chrome Software Engineers<br /><br /><br /><br /><i>Data source for all statistics: <a href=\"https://www.google.com/chrome/privacy/whitepaper.html#usagestats\">Real-world data</a> anonymously aggregated from Chrome clients.</i><br /></div>",
        "contentSnippet": "We are fortunate that so many people choose Chrome as their browser to get things done, which is why we are continually investing in making Chrome more performant. But with software as complex as Chrome, there is a lot of performance left hidden in areas we aren’t actively working on. In our latest post in the The Fast and the Curious series, we investigate how to diagnose, find, and fix performance problems that normally go undetected.\n\n\nThe 1%\nOur metrics show that while Chrome is fast on average, it can be noticeably slow at times. Such user-pain is visible in the 99th percentile of many of our metrics but unreproducible, and thus quite hard to act upon. Deeper analysis in the data shows that the long-tail of performance is not 1% of users on slow machines but rather many users, 1% of the time.\nLet’s talk about 1%. 1% is quite large in practice. The core metric we use is “jank” which is a noticeable delay between when the user gives input and when software reacts to it. Chrome measures jank every 30 seconds, so Jank in 1% of samples for a given user means jank once every 50 minutes. To that user, Chrome feels slow at those moments. Now the problem: can we find and fix the root causes of all the ways Chrome can be momentarily slow for our users?\n\n\n\n\nApproach\nAs engineers, our training in optimization is to focus on improving the algorithmic performance of the components we own. The last 3 years of analyzing the immensely complex codebase of Chrome however have taught us that the real issue is often cross-cutting: multiple unrelated features’ long-tail performance issues, sharing the same systemic root cause(s). Applying local expertise and optimization is likely to miss the global optimum. It is necessary to disregard our initial intuition and assume ignorance, forcing us to dig beyond what is immediately apparent and find the underlying root cause by relentlessly exposing what we don’t know.\n\n\n\n\nChasing Invisible Bugs\nHow do we find bugs that are unforeseen, unreproducible, unowned, and essentially invisible?\nFirst, define a scenario. For this work, we focus on user-visible Jank, which we measure in the field as a way to systematically identify moments where Chrome feels slow.\nSecond, gather high actionability bug reports in the field. For this we rely on Chrome’s BackgroundTracing infrastructure to generate what we call Slow Reports. A subset of Canary users who have opted in to sharing anonymized metrics have circular-buffer tracing enabled to examine specific scenarios. If a preconfigured threshold on a metric of interest is hit, the trace buffer is captured, anonymized, and uploaded to Google servers.\nSuch a bug report might look like this:\n\n\n\n\n\nchrome://tracing view of a 2 seconds Jank on AutocompleteController::UpdateResult() on an otherwise healthy machine\n\nWe have a culprit! Let’s optimize AutocompleteController? No! We don’t know why yet: keep assuming ignorance!\nBy augmenting BackgroundTracing with stack sampling, we were able to find a recurring stack under stalled AutoComplete events:\n\n\n    RegEnumValueW\n\n    RegEnumValueWStub\n    base::win::RegistryValueIterator::Read()\n    gfx::`anonymous namespace\\'::CachedFontLinkSettings::GetLinkedFonts\n    gfx::internal::LinkedFontsIterator::GetLinkedFonts()\n    gfx::internal::LinkedFontsIterator::NextFont(gfx::Font *)\n    gfx::GetFallbackFonts(gfx::Font const &)\n    gfx::RenderTextHarfBuzz::ShapeRuns(...)\n    gfx::RenderTextHarfBuzz::ItemizeAndShapeText(...)\n    gfx::RenderTextHarfBuzz::EnsureLayoutRunList()\n    gfx::RenderTextHarfBuzz::EnsureLayout()\n    gfx::RenderTextHarfBuzz::GetStringSizeF()\n    gfx::RenderTextHarfBuzz::GetStringSize()\n    OmniboxTextView::CalculatePreferredSize()\n    OmniboxTextView::ReapplyStyling()\n    OmniboxTextView::SetText...)\n    OmniboxResultView::Invalidate()\n    OmniboxResultView::SetMatch(AutocompleteMatch const &)\n    OmniboxPopupContentsView::UpdatePopupAppearance()\n    OmniboxPopupModel::OnResultChanged()\n    OmniboxEditModel::OnCurrentMatchChanged()\n    OmniboxController::OnResultChanged(bool)\n    AutocompleteController::UpdateResult(bool,bool)\n    AutocompleteController::Start(AutocompleteInput const &)\n    (...)\n\n\nAh ha! Autocomplete is not at fault. Time to optimize GetFallbackFonts()?! But wait… Why is GetFallbackFonts() even called in the first place?\nAnd before we figure that out, how do we know this is the #1 root cause of our overall long-tail performance issue? We’ve only looked at one trace so far after all...\n\n\n\n\nThe Measurement Conundrum\nThe metrics tell us how many users are affected and how bad it is, but they do not highlight the root cause.\nSlow Reports tell us what the problem is for a specific user but not how many users are affected. And while we can query our corpus of Slow Report traces, it comes with inherent biases that make it impossible to correlate 1:1 with metrics. For instance, because Chrome only reports the first instance of bad performance per-session and only for users of the Canary/Dev channel, there’s both a startup and a population bias.\nThis is the measurement conundrum. The more actionability (data) a tool provides, the fewer scenarios it captures and the more bias it incurs. Depth vs. breadth.\nTools that attempt to do both sit somewhere in the middle, where they use aggregation over a large dataset and risk showing aggregate results based on flawed input (e.g. circular buffer tracing having dropped the interesting portion and contributing to a biased aggregate).\n\n\n\n\nThus we scientifically opted for the least engineering-minded option: open a bunch of Slow Report traces manually. This gave us the most actionability over a top-level issue we’d already quantified.\nAfter opening dozens of traces it turned out that a great majority showed variations of the aforementioned fonts issue. While this didn’t give us a precise #users-affected, it was enough for us to believe it was the main cause of user pain seen in the metrics.\n\n\n\n\n\n\nFallback Fonts\nWe dug into why GetFallbackFonts() had to be called in the first place. In the example above, the caller is trying to determine the size in pixels of a Unicode string rendered by a given font.\nIf a substring within it is from a Unicode Block that can’t be rendered by the given font, GetFallbackFont() is used to request the system recommended fallback font for it. If that fails, GetFallbackFonts() is invoked to try all the linked fonts and determine the one that can best render it; that second fallback is much slower.\nGetFallbackFont() should never fail, but in practice it’s not that simple. The reliable way to do this on Windows is to query DirectWrite; however, DirectWrite was added in Windows 7, when Chrome still supported Windows XP. Therefore the GetFallbackFont() logic was forced to stick to a less reliable heuristic using Uniscribe+GDI in order to work on both versions of the OS. Since things worked most of the time, no one noticed that this could have been cleaned up when Chrome later dropped support for Windows XP. With new tooling to investigate long-tail performance, this turned out to be the number one cause of jank (unnecessarily invoking GetFallbackFonts()).\nWe fixed that, reducing the amount of calls to GetFallbackFonts() by 4x.\n\n\n\n\n\n\nStill not zero though, and still seeing instances of the aforementioned AutoComplete issue in our Slow Reports. Keep digging. DirectWrite’s GetFallbackFont() failing was unexpected, but since Slow Reports are anonymized, no user-generated strings can be uploaded -- and therefore, finding which codepoints were problematic was tricky. We teamed up with our privacy experts to instrument Unicode Block and Script of text blocks going through HarfBuzz so that we could ensure no leakage of Personally Identifiable Information.\n\n\n\n  \nThe Emoji Saga\nWith this new recording enabled, the next wave of Slow Reports came back. The vast majority of reports indicated that font fallback was failing when DirectWrite was being asked to find a font for a codepoint (Unicode character) in Miscellaneous Symbols and Pictographs. We wrote a local script trying all codepoints in that Unicode Block and quickly found out which ones could be problematic: U+1F3FB - U+1F3FF are modifiers added in Unicode 8.0 and are meaningful only when paired with another codepoint. For instance, U+1F9D7 (🧗) when paired with U+1F3FF is 🧗🏿. No font can render U+1F3FF on its own, and font fallback would correctly error out after scanning all linked fonts when asked to find one. The bug was in the browser-side Unicode segmentation logic which incorrectly broke down these two codepoints and asked DirectWrite to render them separately instead of keeping them as a single grapheme.\nBut wait, doesn’t Chrome support modern Unicode..?! Indeed, it does, in Blink which renders the web content. But the browser-side logic was not updated to support modern emojis (with modifiers) because it didn’t use to draw emojis at all. It’s only when the browser UI (tab strip, bookmark bar, omnibox, etc.) was modernized to support Unicode circa 2018 that the legacy segmentation logic became an (invisible) problem.\nOn top of that, the caching logic did not cache on error, so trying to render a modifier on its own caused a massive jank, every time, for users with a lot of fonts installed. Ironically, this cache had been added to amortize the cost of this misunderstood bottleneck when Unicode support was first added to browser UI. Diving deeper into the underlying implementation of our fonts logic, rather than stopping at the layer of the fonts APIs, not only fixed a major performance issue but also resulted in a correctness fix for other emojis. For instance, 🏳️‍🌈 is encoded as U+1F3F3( 🏳️) + U+1F308 (🌈); before the itemization fix, browser UI would incorrectly render this grapheme as 🏳️🌈.\n\n\nAnd the journey continues...\nOur journey keeps going into various components of Chrome but it always follows the same basic playbook: assume ignorance and relentlessly investigate unforeseen, unreproducible, and unowned bugs. And while stack ranking issues is nigh impossible (see: measurement conundrum), fixing the top 5 findings from any given tool and zooming in on the long tail has always addressed the majority of the user pain in practice.\nUsing this approach, we have reduced user-visible jank by a factor of 10X over the last 2.5 years and improved long-tail performance of many features caught in the cross-fire. \n\n\n99th percentile of # of unresponsive 100ms intervals over a 30 seconds sample\n\n\n\nPosted by Gabriel Charette 🤸🏼 and Etienne Bergeron 🕵🏻, Chrome Software Engineers\n\nData source for all statistics: Real-world data anonymously aggregated from Chrome clients.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-6876489512346638549",
        "isoDate": "2021-04-22T19:15:00.001Z"
    },
    {
        "title": "Help users log in across affiliated sites in Chrome",
        "link": "http://blog.chromium.org/2021/04/help-users-log-in-across-affiliated.html",
        "pubDate": "2021-04-22T15:00:00.003Z",
        "author": "Chromium Blog",
        "content": "<p>Chrome can generate a new password, automatically fill saved passwords, sync them and <a href=\"https://security.googleblog.com/2019/12/better-password-protections-in-chrome.html\" target=\"_blank\">warn users when passwords are compromised</a>. This means users do not need to maintain passwords themselves. However, if you employ multiple domains (for example, top-level domains such as <span style=\"font-family: courier;\">https://www.example.com</span> and <span style=\"font-family: courier;\">https://www.example.co.uk</span>) that share the same account management backend, Chrome may not offer to fill passwords across them. This can result in two entries for the same password in different domains, which may get out of sync. </p> <p>Starting in version 91, Chrome will offer to fill passwords saved to domains associated with <a href=\"https://digitalassetlinks.org/\" target=\"_blank\">Digital Asset Links</a> (DALs). DALs have been adopted since 2015, which allow you to <a href=\"https://developers.google.com/digital-asset-links/v1/create-statement\" target=\"_blank\">link Android apps and websites</a>. In Chrome 91, when you set up DALs between sites, Chrome can assist users with logging in across those sites. To make a DAL association, developers need to put a JSON file that follows the <a href=\"https://developers.google.com/digital-asset-links/v1/statements\" target=\"_blank\">DAL syntax</a> at <span style=\"font-family: courier;\">/.well-known/assetlinks.json</span> on both domains.</p> <span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"border: none; display: inline-block; height: 340px; overflow: hidden; width: 624px;\"><img height=\"351.00000000000006\" src=\"https://lh4.googleusercontent.com/rczHJ4oYJmu669rWIw7QJMfIcNY47dRoYMjkqbPU9pLOqrTTqan2e_rAEMPn-jrKhABbYmLWJWdyZgPO71-i2OEiRamadGeIBOsJs3i9yhekqNlFeLZJP6Ss_IJjDkFjQAkYx_PrBk2IWxFS9qaTPjCQOF_D9ljI8L7kL4Yj0wR14iYo\" style=\"margin-left: 0px; margin-top: -5.5px;\" width=\"624\" /></span></span> <p>To learn more about how to set up a DAL association, <a href=\"https://developer.chrome.com/blog/site-affiliation/\" target=\"_blank\">enable Chrome to share login credentials across affiliated sites</a>.</p> <span class=\"post-author\">Posted by Eiji Kitamura, Developer Advocate and Ali Sarraf, Product Manager</span>",
        "contentSnippet": "Chrome can generate a new password, automatically fill saved passwords, sync them and warn users when passwords are compromised. This means users do not need to maintain passwords themselves. However, if you employ multiple domains (for example, top-level domains such as https://www.example.com and https://www.example.co.uk) that share the same account management backend, Chrome may not offer to fill passwords across them. This can result in two entries for the same password in different domains, which may get out of sync. \n Starting in version 91, Chrome will offer to fill passwords saved to domains associated with Digital Asset Links (DALs). DALs have been adopted since 2015, which allow you to link Android apps and websites. In Chrome 91, when you set up DALs between sites, Chrome can assist users with logging in across those sites. To make a DAL association, developers need to put a JSON file that follows the DAL syntax at /.well-known/assetlinks.json on both domains.\n  \nTo learn more about how to set up a DAL association, enable Chrome to share login credentials across affiliated sites.\n Posted by Eiji Kitamura, Developer Advocate and Ali Sarraf, Product Manager",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-7940413607251941672",
        "isoDate": "2021-04-22T15:00:00.003Z"
    },
    {
        "title": "Efficient And Safe Allocations Everywhere!",
        "link": "http://blog.chromium.org/2021/04/efficient-and-safe-allocations-everywhere.html",
        "pubDate": "2021-04-12T18:43:00.008Z",
        "author": "Chromium Blog",
        "content": "<i>In our constant work to improve performance, our engineers sometimes have to seek optimizations in places that most software developers don’t venture. In this post in our series, <a href=\"https://blog.chromium.org/search/label/the%20fast%20and%20the%20curious\" target=\"_blank\">The Fast and the Curious</a>, a team of senior engineers showed how they approached replacing the system-level memory allocator with an optimized version, yielding significant memory savings -- up to 22% on Windows.</i><div><span id=\"docs-internal-guid-205d813a-7fff-ffa5-8e84-59ee1ac08d8e\"><br /></span><a href=\"https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md\">PartitionAlloc</a> is Chromium’s memory allocator, designed for lower fragmentation, higher speed, and stronger security and has been used extensively within <a href=\"https://www.chromium.org/blink\">Blink</a> (Chromium’s rendering engine). <a href=\"https://blog.chromium.org/2021/03/advanced-memory-management-and-more.html\">In Chrome 89</a> the entire Chromium codebase transitioned to using PartitionAlloc everywhere (by intercepting and replacing malloc() and new) on Windows 64-bit and Android. Data from the field demonstrates up to 22% memory savings, and up to 9% improvement in responsiveness and scroll latency of Chrome.</div><div style=\"text-align: center;\"><span id=\"docs-internal-guid-37fac04a-7fff-d5bd-36e5-adf5479bcd56\"><div align=\"left\" dir=\"ltr\" style=\"margin-left: 0pt;\"><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-Ihg91Ojm8m8/YJ3EQlr-TGI/AAAAAAAABgE/E9haZXHITAsSsHyyGcew2UqjS3oo39E8gCLcBGAsYHQ/s605/image3.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"148\" data-original-width=\"605\" height=\"132\" src=\"https://1.bp.blogspot.com/-Ihg91Ojm8m8/YJ3EQlr-TGI/AAAAAAAABgE/E9haZXHITAsSsHyyGcew2UqjS3oo39E8gCLcBGAsYHQ/w542-h132/image3.png\" width=\"542\" /></a></div></div></div><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div></span></div><div><span><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\">Here's a closer look at memory usage in the browser process for Windows as the M89 release began rolling out in early March:</p></span><div><br /><span><span face=\"Roboto, sans-serif\"><div align=\"left\" dir=\"ltr\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; margin-left: 0pt; vertical-align: baseline; white-space: pre-wrap;\"><span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\"><br /></span></span></div><div align=\"left\" dir=\"ltr\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; margin-left: 0pt; vertical-align: baseline; white-space: pre-wrap;\"><span><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\"><br /></span></span></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-xPn1ldBnT6Q/YJ3EDW6o8CI/AAAAAAAABf8/0V5dKoNA1mklSBU9dCBECrWXmtXyNMCFwCLcBGAsYHQ/s1458/image2.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"709\" data-original-width=\"1458\" height=\"256\" src=\"https://1.bp.blogspot.com/-xPn1ldBnT6Q/YJ3EDW6o8CI/AAAAAAAABf8/0V5dKoNA1mklSBU9dCBECrWXmtXyNMCFwCLcBGAsYHQ/w524-h256/image2.png\" width=\"524\" /></a></div><br /><div dir=\"ltr\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; margin-left: 0pt; text-align: center; vertical-align: baseline; white-space: pre-wrap;\"><br /></div><div align=\"left\" dir=\"ltr\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; margin-left: 0pt; vertical-align: baseline; white-space: pre-wrap;\"><br /></div></span><h4 style=\"text-align: left;\"><br /></h4><h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span id=\"docs-internal-guid-7831b3f4-7fff-68ce-e77b-058ddf504699\"><span face=\"Roboto, sans-serif\" style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Background</span></span></span></h2></span></div><span><span>Chrome is a multi-platform, multi-process, multi-threaded application, serving a wide range of needs, from small embedded <a href=\"https://developer.android.com/reference/android/webkit/WebView\">WebViews</a> on Android to <a href=\"https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/ft5zou3?utm_source=share&amp;utm_medium=web2x&amp;context=3\">spacecraft</a>. Performance and memory footprint are of critical importance, requiring a tight integration between Chrome and its memory allocator. But heterogeneity across platforms can be prohibitive with each platform having a different implementation such as <a href=\"https://github.com/google/tcmalloc\">tcmalloc</a> on Linux and Chrome OS, <a href=\"http://jemalloc.net/\">jemalloc</a> or <a href=\"https://source.android.com/devices/tech/debug/scudo\">scudo</a> on Android, and <a href=\"https://docs.microsoft.com/en-us/windows/win32/memory/low-fragmentation-heap\">LFH</a> on Windows.<br /><br /><br /></span></span>When we started this project, our goals were to: 1) unify memory allocation across platforms, 2) target the lowest memory footprint without compromising security and performance, and 3) tailor the allocator to optimize the performance of Chrome. Thus we made the decision to use Chromium’s cross-platform allocator, to optimize memory usage for client rather than server workloads and to focus on meaningful end user activities, not micro-benchmarks that wouldn’t really matter in real world usage.</div><div><br /></div><div><br /></div><div><br /><span><span><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><br /></span></p><h2 style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt; text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span id=\"docs-internal-guid-39bf727d-7fff-c0cc-7eb2-d0f1bf5a0134\"><span style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Allocator Security</span></span></span></h2><div><br /></div></span></span>PartitionAlloc was designed to support multiple independent partitions, i.e. non-overlapping regions of memory. We use these partitions throughout Blink to thwart some forms of type confusion attacks, such as ensuring strings are separated from layout objects. However, this approach only avoids collisions between types that are allocated from different partitions. Furthermore, PartitionAlloc buckets allocations by their sizes, to help avoid type confusion when potentially-colliding objects are of dissimilar size. These techniques work because PartitionAlloc doesn’t re-use address space. Once PartitionAlloc dedicates a region of address space to a certain partition and size bucket, it will always belong to that partition and size bucket.<br /><br /><br />Additionally, PartitionAlloc protects some of its metadata with guard pages (inaccessible ranges) around memory regions. Not all metadata is equal, however: free-list entries are stored within previously allocated regions, and thus surrounded by other allocations. To detect corrupted free-list entries and off-by-one overflows from client code, we encode and shadow them.<br />Finally, having our own allocator enables advanced security features like <a href=\"https://source.chromium.org/chromium/chromium/src/+/master:base/memory/checked_ptr.md\">MiraclePtr</a> and <a href=\"https://source.chromium.org/chromium/chromium/src/+/master:base/allocator/partition_allocator/starscan/README.md\">*Scan</a>.</div><div><br /></div><div><br /></div><div><br /><span><span><h2 style=\"text-align: left;\"><span face=\"Roboto, sans-serif\" style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\"><span id=\"docs-internal-guid-30a50237-7fff-5323-2761-bd58302d04c1\"><span style=\"font-size: 16pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">Architecture Details</span></span></span></span></h2></span></span><div>Each partition in PartitionAlloc uses a single, central, <a href=\"https://en.wikipedia.org/wiki/Slab_allocation\" style=\"font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">slab-based allocator</a> to conserve memory, with a minimal per-thread cache in front for scaling to multi-threaded workloads. This simplicity also pays performance dividends: we’ve extensively profiled and aggressively trimmed the allocator’s fast path, improving thread-local storage access, locks, reducing cache line fetches, and removing branches.<br /><br />PartitionAlloc pre-reserves slabs of virtual address space. They are gradually backed by physical memory, as allocation requests arrive. Small and medium-sized allocations are grouped in geometrically-spaced, size-segregated buckets, e.g. [241; 256], [257; 288]. Each slab is split into regions (called “slot spans”) that satisfy allocations (“slots”) from only one particular bucket, thereby increasing cache locality while lowering fragmentation. Conversely, larger allocations don’t go through the bucket logic and are fulfilled using the operating system’s primitives directly (mmap() on <a href=\"https://en.wikipedia.org/wiki/POSIX\" style=\"font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;\">POSIX</a> systems, and VirtualAlloc() on Windows).<br /><br />This central allocator is protected by a single per-partition lock. To mitigate the scalability problem arising from contention, we add a small, per-thread cache of small slots in front, yielding a three-tiered architecture:</div><div><br /></div><div><br /><span><span><span face=\"Roboto, sans-serif\"><span><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-u81A8RlMHII/YJ3EcBTg7ZI/AAAAAAAABgM/Yqy59xemy80ba3haKC2JsGsANG_cbxzawCLcBGAsYHQ/s276/image1.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"196\" data-original-width=\"276\" src=\"https://1.bp.blogspot.com/-u81A8RlMHII/YJ3EcBTg7ZI/AAAAAAAABgM/Yqy59xemy80ba3haKC2JsGsANG_cbxzawCLcBGAsYHQ/s0/image1.png\" /></a></div><br /><div style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt; text-align: center; vertical-align: baseline; white-space: pre-wrap;\"><br /></div></span></span></span></span>The first layer (Per-thread cache) holds a small amount of slots belonging to smaller and more commonly used buckets. Because these slots are stored per-thread, they can be allocated without a lock and only requiring a faster <a href=\"https://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage</a> lookup, improving cache locality in the process. The per-thread cache has been tailored to satisfy the majority of requests by allocating from and releasing memory to the second layer in batches, amortizing lock acquisition, and further improving locality while not trapping excess memory.<br /><br />The second layer (Slot span free-lists) is invoked upon a per-thread cache miss. For each bucket size, PartitionAlloc knows a slot span with free slots associated with that size, and captures a slot from the free-list of that span. This is still a fast path, but slower than per-thread cache as it requires taking a lock. However, this section is only hit for larger allocations not supported by per-thread cache, or as a batch to fill the per-thread cache.<br /><br />Finally, if there are no free slots in the bucket, the third layer (Slot span management) either carves out space from a slab for a new slot span, or allocates an entirely new slab from the operating system, which is a slow but very infrequent operation.<br /><br />The overall performance and space-efficiency of the allocator hinges on the many tradeoffs across its layers such as how much to cache, how many buckets, and memory reclaiming policy. Please refer to <a href=\"https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md\">PartitionAlloc</a> to learn more about the design.<br /><br />All in all, we hope you will enjoy the additional memory savings and performance improvements brought by PartitionAlloc, ensuring a safer, leaner, and faster Chrome for users on Earth and in outer space alike. Stay tuned for further improvements, and support of more platforms coming in the near future.<br /><br />Posted by Benoît Lizé and Bartek Nowierski, Chrome Software Engineers</div><div><br /><i>Data source for all statistics: <a href=\"https://www.google.com/chrome/privacy/whitepaper.html#usagestats\">Real-world data</a> anonymously aggregated from Chrome clients.<br />*The core metric measures jank -- delay handling user input -- every 30 seconds.</i><span><span><span face=\"Roboto, sans-serif\"><span><div style=\"font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt; vertical-align: baseline; white-space: pre-wrap;\"><br /></div></span></span></span></span></div></div>",
        "contentSnippet": "In our constant work to improve performance, our engineers sometimes have to seek optimizations in places that most software developers don’t venture. In this post in our series, The Fast and the Curious, a team of senior engineers showed how they approached replacing the system-level memory allocator with an optimized version, yielding significant memory savings -- up to 22% on Windows.\n\nPartitionAlloc is Chromium’s memory allocator, designed for lower fragmentation, higher speed, and stronger security and has been used extensively within Blink (Chromium’s rendering engine). In Chrome 89 the entire Chromium codebase transitioned to using PartitionAlloc everywhere (by intercepting and replacing malloc() and new) on Windows 64-bit and Android. Data from the field demonstrates up to 22% memory savings, and up to 9% improvement in responsiveness and scroll latency of Chrome.\n\n\n\n\n\n\n\n\n\n\nHere's a closer look at memory usage in the browser process for Windows as the M89 release began rolling out in early March:\n\n\n\n\n\n\n\n\n\n\n\n\nBackground\n\nChrome is a multi-platform, multi-process, multi-threaded application, serving a wide range of needs, from small embedded WebViews on Android to spacecraft. Performance and memory footprint are of critical importance, requiring a tight integration between Chrome and its memory allocator. But heterogeneity across platforms can be prohibitive with each platform having a different implementation such as tcmalloc on Linux and Chrome OS, jemalloc or scudo on Android, and LFH on Windows.\n\nWhen we started this project, our goals were to: 1) unify memory allocation across platforms, 2) target the lowest memory footprint without compromising security and performance, and 3) tailor the allocator to optimize the performance of Chrome. Thus we made the decision to use Chromium’s cross-platform allocator, to optimize memory usage for client rather than server workloads and to focus on meaningful end user activities, not micro-benchmarks that wouldn’t really matter in real world usage.\n\n\n\n\n\n\n\nAllocator Security\n\nPartitionAlloc was designed to support multiple independent partitions, i.e. non-overlapping regions of memory. We use these partitions throughout Blink to thwart some forms of type confusion attacks, such as ensuring strings are separated from layout objects. However, this approach only avoids collisions between types that are allocated from different partitions. Furthermore, PartitionAlloc buckets allocations by their sizes, to help avoid type confusion when potentially-colliding objects are of dissimilar size. These techniques work because PartitionAlloc doesn’t re-use address space. Once PartitionAlloc dedicates a region of address space to a certain partition and size bucket, it will always belong to that partition and size bucket.\n\nAdditionally, PartitionAlloc protects some of its metadata with guard pages (inaccessible ranges) around memory regions. Not all metadata is equal, however: free-list entries are stored within previously allocated regions, and thus surrounded by other allocations. To detect corrupted free-list entries and off-by-one overflows from client code, we encode and shadow them.\nFinally, having our own allocator enables advanced security features like MiraclePtr and *Scan.\n\n\n\n\n\nArchitecture Details\n\nEach partition in PartitionAlloc uses a single, central, slab-based allocator to conserve memory, with a minimal per-thread cache in front for scaling to multi-threaded workloads. This simplicity also pays performance dividends: we’ve extensively profiled and aggressively trimmed the allocator’s fast path, improving thread-local storage access, locks, reducing cache line fetches, and removing branches.\nPartitionAlloc pre-reserves slabs of virtual address space. They are gradually backed by physical memory, as allocation requests arrive. Small and medium-sized allocations are grouped in geometrically-spaced, size-segregated buckets, e.g. [241; 256], [257; 288]. Each slab is split into regions (called “slot spans”) that satisfy allocations (“slots”) from only one particular bucket, thereby increasing cache locality while lowering fragmentation. Conversely, larger allocations don’t go through the bucket logic and are fulfilled using the operating system’s primitives directly (mmap() on POSIX systems, and VirtualAlloc() on Windows).\nThis central allocator is protected by a single per-partition lock. To mitigate the scalability problem arising from contention, we add a small, per-thread cache of small slots in front, yielding a three-tiered architecture:\n\n\n\n\n\n\nThe first layer (Per-thread cache) holds a small amount of slots belonging to smaller and more commonly used buckets. Because these slots are stored per-thread, they can be allocated without a lock and only requiring a faster thread-local storage lookup, improving cache locality in the process. The per-thread cache has been tailored to satisfy the majority of requests by allocating from and releasing memory to the second layer in batches, amortizing lock acquisition, and further improving locality while not trapping excess memory.\nThe second layer (Slot span free-lists) is invoked upon a per-thread cache miss. For each bucket size, PartitionAlloc knows a slot span with free slots associated with that size, and captures a slot from the free-list of that span. This is still a fast path, but slower than per-thread cache as it requires taking a lock. However, this section is only hit for larger allocations not supported by per-thread cache, or as a batch to fill the per-thread cache.\nFinally, if there are no free slots in the bucket, the third layer (Slot span management) either carves out space from a slab for a new slot span, or allocates an entirely new slab from the operating system, which is a slow but very infrequent operation.\nThe overall performance and space-efficiency of the allocator hinges on the many tradeoffs across its layers such as how much to cache, how many buckets, and memory reclaiming policy. Please refer to PartitionAlloc to learn more about the design.\nAll in all, we hope you will enjoy the additional memory savings and performance improvements brought by PartitionAlloc, ensuring a safer, leaner, and faster Chrome for users on Earth and in outer space alike. Stay tuned for further improvements, and support of more platforms coming in the near future.\nPosted by Benoît Lizé and Bartek Nowierski, Chrome Software Engineers\n\nData source for all statistics: Real-world data anonymously aggregated from Chrome clients.\n*The core metric measures jank -- delay handling user input -- every 30 seconds.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-2865802626526343026",
        "isoDate": "2021-04-12T18:43:00.008Z"
    },
    {
        "title": "Don’t Copy That Surface",
        "link": "http://blog.chromium.org/2021/04/dont-copy-that-surface.html",
        "pubDate": "2021-04-05T16:48:00.005Z",
        "author": "Chromium Blog",
        "content": "<br /><i>This post is part of a new series <a href=\"https://blog.chromium.org/search/label/the%20fast%20and%20the%20curious\">The Fast and the Curious</a> we're bringing you of deeper dives into the careful trade-offs and complex engineering that goes into making Chrome fast and reliable. This debugging adventure by Chrome developer and <a href=\"https://randomascii.wordpress.com/\" target=\"_blank\">blogger</a> Bruce Dawson reduced CPU usage by about 3% when using a webcam - a real help for those of us relying on video calls.</i><br /><div><i><br /></i></div><div>Video conferencing took on elevated importance in 2020. I’m not on the <a href=\"https://meet.google.com/\" target=\"_blank\">Google Meet</a> team but I do work on Chrome, so I fired up my <a href=\"https://randomascii.wordpress.com/2015/09/24/etw-central/\" target=\"_blank\">favorite profiler</a> during one of my daily meetings to see if I could find anything useful.<br /><div><div><div><br /></div><div>There is a lot going on during video conferencing, spread across multiple processes. With my usual dozens of tabs open there were 37 Chrome processes, with six of them actively participating in the video conference. In addition there were over 200 other processes running (87 copies of svchost.exe, for instance), with four of those involved in video conferencing. You may well wonder why it takes 10 processes to connect two people, so here is a list of the processes and their roles:<br /><br /><ul style=\"text-align: left;\"><li>audiodg.exe - Windows Audio Device Graph Isolation, audio output</li><li>dwm.exe - Windows Desktop Window Manager, showing video</li><li>svchost.exe - Windows Camera Frame Server (webcam capture)</li><li>System - Windows system process, does miscellaneous tasks on behalf of processes</li><li>chrome.exe - browser process, the master control program</li><li>chrome.exe - renderer process, the Meet tab</li><li>chrome.exe - GPU process, in charge of rendering pages</li><li>chrome.exe - NetworkService utility process, talking to the network</li><li>chrome.exe - VideoCaptureService, talking to the Windows Camera Frame Server</li><li>chrome.exe - AudioService, controls audio input and output</li></ul><br />These tasks are spread across different processes for security and stability. If one of them crashes it can be restarted without taking everything down. If one of them is compromised due to a security bug then it is isolated from the rest of the system and the damage may be contained.<br /><br />This all makes good sense, but having this many processes involved can make performance-profiling challenging. It can be challenging to look through all of these processes to find areas of potential improvement. It is made more difficult by the fact that I know little about the Meet architecture.</div><div><br /></div><div><br /><h1 style=\"text-align: left;\"><span style=\"font-size: large;\">Analyzing a profile</span></h1>Video conferencing is CPU intensive - you have to record, compress, transmit, receive, decompress, and display both audio and video. The data below shows CPU samples recorded by Microsoft’s Event Tracing for Windows (ETW). This sampling profiler works by interrupting every running thread about 1,000 times a second and recording a call stack. I used Windows Performance Analyzer (WPA) to display the results. In the screenshot below I am looking at a 10-second period and over 16,000 samples (representing about 16 seconds of CPU time) were recorded across the 10 processes involved in video conferencing:</div><div><br /></div><div><div style=\"text-align: center;\"><img height=\"195\" src=\"https://lh5.googleusercontent.com/jzlLM_kx9rWqLFCR7Y2PlvT2OGUPwSpS4caexwk05o7FVObNRdVOvRSnSLMZsuCEAjDM9e22UGr-XwTaf312_HwIp-gEgvCihj_yqxfauDSAXRjv9mNCuiY9DwU4TZco2x184EXocQ\" style=\"font-family: Arial; font-size: 11pt; margin-left: 0px; margin-top: 0px; white-space: pre-wrap;\" width=\"624\" /></div><br /><br />That’s a lot of samples to look through, but the call stacks are collated so that you can drill down on the busiest stacks. I didn’t find anything in the first Chrome process, but in the second one I did:</div><div><br /></div><div><div style=\"text-align: center;\"><img height=\"481\" src=\"https://lh5.googleusercontent.com/u4U4H83xvkp9Rz8HITeRs4y8Xw5E7iZsHxmGrk6mNT3AHy7Djupl5VC387-XKEkeGeAZ0w66Xg-Xu8Q4EOpf2Yq8QdIhVUtitNUU47qIjcTftrGvJMvHd7FZRcV8M29EwRjRGFJFag\" style=\"font-family: Arial; font-size: 11pt; margin-left: 0px; margin-top: 0px; white-space: pre-wrap;\" width=\"624\" /></div><br />It doesn’t look like much, but I recognized immediately that the 124 samples in KiPageFault were worth investigating. Most of the CPU-intensive work in this trace was important and unavoidable work but I had a hunch that these samples represented avoidable work - something that I could fix. And, even though they represented just 0.75% of the samples I suspected that they indicated a somewhat greater cost.<br /><br />I recognized their importance immediately because this is something that I have seen before. <a href=\"https://en.wikipedia.org/wiki/Demand_paging\" target=\"_blank\">KiPageFault</a> means that the processor touched some memory that had been allocated, but was not currently in the process. This could mean that the pages had been removed from the process to save memory, but in an active process on a machine with lots of memory, that didn’t make sense. What was more likely was that this represented recently allocated memory.<br /><br />When a program allocates a small amount of memory, the local memory manager (sometimes called the “heap”) will usually have some available that it can give to the program. But if it doesn’t have an appropriate block of memory then it will ask the operating system (OS) for some. If a program allocates a large amount of memory (greater than a MB or so) then the heap will definitely ask for more memory. This is, in itself, a relatively cheap operation. The heap asks the OS for some memory, the OS says “sure”, then the OS makes note of the fact that it promised this memory, and that’s it. The OS does not, at that time, actually give the program any memory. This is the way of the world on Windows, Linux, Android and it is good but it can be confusing and surprising. If the process never touches the memory then the memory is never added to the process, but if the process does touch the memory then individual pages of zeroed memory are brought into the process. These are called <a href=\"https://stackoverflow.com/questions/5684365/what-causes-page-faults\" target=\"_blank\">demand-zero page faults</a> because zeroed pages are “faulted” into the process on demand.<br /><br />In other words, allocating a large block of memory is quite cheap, but doesn’t actually set up the promised memory. Then, when the program tries to use the memory and the CPU discovers that there is no memory at that address it triggers an exception, which wakes up the OS. The OS checks its records and realizes that it did in fact promise to put memory at that address so it then puts some there and restarts the program. This happens so quickly that if you’re not paying attention you will miss it, but it shows up when profiling as samples hitting in KiPageFault.<br /><br />This bizarre dance happens again for every 4-KiB block in the allocation - 4 KiB is the size of the pages that the CPU and the OS work on.<br /><br />The cost is small. Across this 10-second period only 124 samples - representing about 124 ms or 0.124 seconds - hit inside of KiPageFault. The total cost of the enclosing CopyImage_SSE4_1 function was about 240 ms, so the page faults accounted for more than half of this function, but barely a quarter of the cost of the OnSample function on line 15.<br /><br />The total costs of these page faults is modest but they hint at many other costs:<br /><ul style=\"text-align: left;\"><li>If this memory is being allocated repeatedly (presumably every frame) then it must also be freed every frame. On line 26 we can see that the Release function which frees the memory uses another 64 samples.</li><li>When the pages are freed the operating system has to zero them (for security reasons) so that they are ready to be reused. This is done in the Windows System process - an almost entirely hidden cost. Sure enough when I looked in the System process I saw 138 samples in the MiZeroPageThread. I found that 87% of the KiPageFault samples in the entire system were in the CopyImage_SSE4_1 call so presumably 87% of the 138 samples in the MiZeroPageThread were due to this pattern.</li></ul><div style=\"text-align: center;\"><span id=\"docs-internal-guid-898c4752-7fff-62e3-c338-b5cde4eeaf1f\"><span style=\"border: none; display: inline-block; height: 133px; overflow: hidden; width: 358px;\"><img height=\"133\" src=\"https://lh4.googleusercontent.com/sVhd7AxlSjSNpKZvB1TdSqDrN_rwdgnWKynCNwK8TBv6Re52SXmZsk3QPSP5sO8-nz0HDFF02nPOv1Ts-u8o41_jKOzBTuwNdwoeWRzJew7kWIAd2JzFlHBV8d2MipPFObKAl0SPkQ\" style=\"margin-left: 0px; margin-top: 0px;\" width=\"358\" /></span></span></div><br /><br />I analyzed these <a href=\"https://randomascii.wordpress.com/2014/12/10/hidden-costs-of-memory-allocation/\" target=\"_blank\">hidden costs of memory allocation</a> in a 2014 blog post. The basic memory architecture of Windows hasn’t changed since then so the hidden costs remain about the same.<br /><br />In addition to CPU samples my ETW trace contained call stacks for every call to VirtualAlloc. This WPA screenshot shows a 10-second period where the OnSample function does 298 allocations that are each 1.320 MB, roughly 30 per second:<br /><br /><div style=\"text-align: center;\"><img height=\"416\" src=\"https://lh6.googleusercontent.com/vJCAnXBCoeip77VshlRUB3aiIUr-imbJ8hOvxFdgRKTRNUcxElMNUgatIELYpGPfpgTwLtB-fOXgNjJgQrM7MwUb0PjW1KAft4efuf0hgVHD0XZld5rCRnknpAxHbRi5KgOJTHimlw\" style=\"font-family: Arial; font-size: 11pt; margin-left: 0px; margin-top: 0px; white-space: pre-wrap;\" width=\"624\" /></div><br />At this point we can estimate that the cost of these repeated allocations is 124 (faulting in) plus 64 (freeing) plus 124 (87% of the zeroing samples) for a total of 312 samples. This gets us up to 1.9% of the total CPU cost of video conferencing. Fixing this is not going to change the world, but this is a change worth doing.<br /><br /></div><div><h1 style=\"text-align: left;\"><span style=\"font-size: large;\">But wait, there’s more!</span></h1>We are locking this buffer so that we can look at the contents, but it turns out we don’t actually want the lock call to copy the buffer at all. We just want the lock call to describe the buffer to us so that we can look at it in place. Therefore the entire cost of the MFCopyImage call is waste! That’s another 116 samples. In addition, in the CMF2DMediaBuffer::Unlock call on line 26 there is another call to CMF2DMediaBuffer::ContiguousCopyFrom. That’s because the Unlock call assumes that we might have modified the copy of the buffer, so it copies it back. So the 101 samples there are all waste as well!<br /><br />If we can examine this buffer without the alloc/copy/copy/free dance then we can save 312 samples plus 116 samples (the rest of the copying cost) plus 101 samples (the copying-it-back cost) for a total saving of 3.2%. This is getting better all the time.<br /><br />Note that sampled data is only statistically valid, and the actual percentages vary significantly depending on the computer and the exact workload. But, the point remains - it is a non-dramatic but worthwhile change to investigate.<br /><br />Despite spending years in the video-game business my knowledge of these graphics-buffer locking and unlocking APIs is weak. I ended up relying on the wisdom of my Twitter followers to come to the conclusion that the copying was entirely avoidable, and to get a rough pattern for how it could be fixed. After <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=1071180\" target=\"_blank\">filing an overly verbose bug</a> I delegated the task of actually fixing it. The <a href=\"https://chromium-review.googlesource.com/c/chromium/src/+/2207580\" target=\"_blank\">fix landed in M85</a> and was deemed important enough that it was then <a href=\"https://chromium-review.googlesource.com/c/chromium/src/+/2219172\" target=\"_blank\">backported to M84</a>.<br /><br />You’d have to be paying very close attention to see the difference - spread across a Chrome process and the system process - but I hope that this helped some computers run a bit cooler and last longer on their batteries. And, while this inefficiency was found by profiling Google Meet, the improvement actually benefits any product that uses the webcam inside Chrome (and other Chromium-based browsers).<br /><br /></div><div><h1 style=\"text-align: left;\"><span style=\"font-size: large;\">Verification</span></h1>After the fix landed I compared two 10-second ETW traces from Chrome Canary before and after the change, each taken with no other programs running except a single Chrome tab running the Google Meet pre-meeting page. In both cases I looked at a 10-second period of time in the profiler. This showed:<br /><br /><br /><b>CPU time in OnSample:</b><br /></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div>Before: 458 ms (432 ms of which were in Lock/Unlock/KiPageFault)</div><div>After:    27 ms</div></blockquote><div><br /><br /><b>Allocations:</b><br /></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div>Before: 30 allocations per second of 1.32 MB (one per frame, running at 30 fps - a higher framerate would mean more allocations), totalling 396 MB over 10 seconds</div><div>After:    0 allocations</div></blockquote><div><br /><br /><b>CPU time in the System process's MiZeroPageThread:</b><br /></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div>Before: 36 ms</div><div>After:    0 ms</div></blockquote><div><br />These measurements showed - in three different ways - that the performance problem was fixed. The memory copying in OnSample was gone, the repeated allocations were gone, and the system process was doing less work. Mission accomplished, <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=1071180#c18\" target=\"_blank\">bug closed</a>.<br /><br /><br /></div></div></div></div>",
        "contentSnippet": "This post is part of a new series The Fast and the Curious we're bringing you of deeper dives into the careful trade-offs and complex engineering that goes into making Chrome fast and reliable. This debugging adventure by Chrome developer and blogger Bruce Dawson reduced CPU usage by about 3% when using a webcam - a real help for those of us relying on video calls.\n\n\nVideo conferencing took on elevated importance in 2020. I’m not on the Google Meet team but I do work on Chrome, so I fired up my favorite profiler during one of my daily meetings to see if I could find anything useful.\n\n\n\nThere is a lot going on during video conferencing, spread across multiple processes. With my usual dozens of tabs open there were 37 Chrome processes, with six of them actively participating in the video conference. In addition there were over 200 other processes running (87 copies of svchost.exe, for instance), with four of those involved in video conferencing. You may well wonder why it takes 10 processes to connect two people, so here is a list of the processes and their roles:\n\naudiodg.exe - Windows Audio Device Graph Isolation, audio output\ndwm.exe - Windows Desktop Window Manager, showing video\nsvchost.exe - Windows Camera Frame Server (webcam capture)\nSystem - Windows system process, does miscellaneous tasks on behalf of processes\nchrome.exe - browser process, the master control program\nchrome.exe - renderer process, the Meet tab\nchrome.exe - GPU process, in charge of rendering pages\nchrome.exe - NetworkService utility process, talking to the network\nchrome.exe - VideoCaptureService, talking to the Windows Camera Frame Server\nchrome.exe - AudioService, controls audio input and output\n\nThese tasks are spread across different processes for security and stability. If one of them crashes it can be restarted without taking everything down. If one of them is compromised due to a security bug then it is isolated from the rest of the system and the damage may be contained.\nThis all makes good sense, but having this many processes involved can make performance-profiling challenging. It can be challenging to look through all of these processes to find areas of potential improvement. It is made more difficult by the fact that I know little about the Meet architecture.\n\n\n\nAnalyzing a profile\nVideo conferencing is CPU intensive - you have to record, compress, transmit, receive, decompress, and display both audio and video. The data below shows CPU samples recorded by Microsoft’s Event Tracing for Windows (ETW). This sampling profiler works by interrupting every running thread about 1,000 times a second and recording a call stack. I used Windows Performance Analyzer (WPA) to display the results. In the screenshot below I am looking at a 10-second period and over 16,000 samples (representing about 16 seconds of CPU time) were recorded across the 10 processes involved in video conferencing:\n\n\n\n\nThat’s a lot of samples to look through, but the call stacks are collated so that you can drill down on the busiest stacks. I didn’t find anything in the first Chrome process, but in the second one I did:\n\n\n\nIt doesn’t look like much, but I recognized immediately that the 124 samples in KiPageFault were worth investigating. Most of the CPU-intensive work in this trace was important and unavoidable work but I had a hunch that these samples represented avoidable work - something that I could fix. And, even though they represented just 0.75% of the samples I suspected that they indicated a somewhat greater cost.\nI recognized their importance immediately because this is something that I have seen before. KiPageFault means that the processor touched some memory that had been allocated, but was not currently in the process. This could mean that the pages had been removed from the process to save memory, but in an active process on a machine with lots of memory, that didn’t make sense. What was more likely was that this represented recently allocated memory.\nWhen a program allocates a small amount of memory, the local memory manager (sometimes called the “heap”) will usually have some available that it can give to the program. But if it doesn’t have an appropriate block of memory then it will ask the operating system (OS) for some. If a program allocates a large amount of memory (greater than a MB or so) then the heap will definitely ask for more memory. This is, in itself, a relatively cheap operation. The heap asks the OS for some memory, the OS says “sure”, then the OS makes note of the fact that it promised this memory, and that’s it. The OS does not, at that time, actually give the program any memory. This is the way of the world on Windows, Linux, Android and it is good but it can be confusing and surprising. If the process never touches the memory then the memory is never added to the process, but if the process does touch the memory then individual pages of zeroed memory are brought into the process. These are called demand-zero page faults because zeroed pages are “faulted” into the process on demand.\nIn other words, allocating a large block of memory is quite cheap, but doesn’t actually set up the promised memory. Then, when the program tries to use the memory and the CPU discovers that there is no memory at that address it triggers an exception, which wakes up the OS. The OS checks its records and realizes that it did in fact promise to put memory at that address so it then puts some there and restarts the program. This happens so quickly that if you’re not paying attention you will miss it, but it shows up when profiling as samples hitting in KiPageFault.\nThis bizarre dance happens again for every 4-KiB block in the allocation - 4 KiB is the size of the pages that the CPU and the OS work on.\nThe cost is small. Across this 10-second period only 124 samples - representing about 124 ms or 0.124 seconds - hit inside of KiPageFault. The total cost of the enclosing CopyImage_SSE4_1 function was about 240 ms, so the page faults accounted for more than half of this function, but barely a quarter of the cost of the OnSample function on line 15.\nThe total costs of these page faults is modest but they hint at many other costs:\n\nIf this memory is being allocated repeatedly (presumably every frame) then it must also be freed every frame. On line 26 we can see that the Release function which frees the memory uses another 64 samples.\nWhen the pages are freed the operating system has to zero them (for security reasons) so that they are ready to be reused. This is done in the Windows System process - an almost entirely hidden cost. Sure enough when I looked in the System process I saw 138 samples in the MiZeroPageThread. I found that 87% of the KiPageFault samples in the entire system were in the CopyImage_SSE4_1 call so presumably 87% of the 138 samples in the MiZeroPageThread were due to this pattern.\n\n\n\nI analyzed these hidden costs of memory allocation in a 2014 blog post. The basic memory architecture of Windows hasn’t changed since then so the hidden costs remain about the same.\nIn addition to CPU samples my ETW trace contained call stacks for every call to VirtualAlloc. This WPA screenshot shows a 10-second period where the OnSample function does 298 allocations that are each 1.320 MB, roughly 30 per second:\n\n\nAt this point we can estimate that the cost of these repeated allocations is 124 (faulting in) plus 64 (freeing) plus 124 (87% of the zeroing samples) for a total of 312 samples. This gets us up to 1.9% of the total CPU cost of video conferencing. Fixing this is not going to change the world, but this is a change worth doing.\n\n\nBut wait, there’s more!\nWe are locking this buffer so that we can look at the contents, but it turns out we don’t actually want the lock call to copy the buffer at all. We just want the lock call to describe the buffer to us so that we can look at it in place. Therefore the entire cost of the MFCopyImage call is waste! That’s another 116 samples. In addition, in the CMF2DMediaBuffer::Unlock call on line 26 there is another call to CMF2DMediaBuffer::ContiguousCopyFrom. That’s because the Unlock call assumes that we might have modified the copy of the buffer, so it copies it back. So the 101 samples there are all waste as well!\nIf we can examine this buffer without the alloc/copy/copy/free dance then we can save 312 samples plus 116 samples (the rest of the copying cost) plus 101 samples (the copying-it-back cost) for a total saving of 3.2%. This is getting better all the time.\nNote that sampled data is only statistically valid, and the actual percentages vary significantly depending on the computer and the exact workload. But, the point remains - it is a non-dramatic but worthwhile change to investigate.\nDespite spending years in the video-game business my knowledge of these graphics-buffer locking and unlocking APIs is weak. I ended up relying on the wisdom of my Twitter followers to come to the conclusion that the copying was entirely avoidable, and to get a rough pattern for how it could be fixed. After filing an overly verbose bug I delegated the task of actually fixing it. The fix landed in M85 and was deemed important enough that it was then backported to M84.\nYou’d have to be paying very close attention to see the difference - spread across a Chrome process and the system process - but I hope that this helped some computers run a bit cooler and last longer on their batteries. And, while this inefficiency was found by profiling Google Meet, the improvement actually benefits any product that uses the webcam inside Chrome (and other Chromium-based browsers).\n\n\nVerification\nAfter the fix landed I compared two 10-second ETW traces from Chrome Canary before and after the change, each taken with no other programs running except a single Chrome tab running the Google Meet pre-meeting page. In both cases I looked at a 10-second period of time in the profiler. This showed:\n\nCPU time in OnSample:\n\nBefore: 458 ms (432 ms of which were in Lock/Unlock/KiPageFault)\nAfter:    27 ms\n\n\nAllocations:\n\nBefore: 30 allocations per second of 1.32 MB (one per frame, running at 30 fps - a higher framerate would mean more allocations), totalling 396 MB over 10 seconds\nAfter:    0 allocations\n\n\nCPU time in the System process's MiZeroPageThread:\n\nBefore: 36 ms\nAfter:    0 ms\n\nThese measurements showed - in three different ways - that the performance problem was fixed. The memory copying in OnSample was gone, the repeated allocations were gone, and the system process was doing less work. Mission accomplished, bug closed.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-9010797736590693838",
        "isoDate": "2021-04-05T16:48:00.005Z"
    },
    {
        "title": "A safer default for navigation: HTTPS",
        "link": "http://blog.chromium.org/2021/03/a-safer-default-for-navigation-https.html",
        "pubDate": "2021-03-23T15:00:00.002Z",
        "author": "Chromium Blog",
        "content": "<p>Starting in version 90, Chrome’s address bar will use <i>https://</i> by default, improving privacy and even loading speed for users visiting websites that support HTTPS. Chrome users who navigate to websites by manually typing a URL often don’t include “http://” or “https://”. For example, users often type “example.com” instead of “https://example.com” in the address bar. In this case, if it was a user’s first visit to a website, Chrome would previously choose <i>http://</i> as the default protocol<sup>1</sup>. This was a practical default in the past, when much of the web did not support HTTPS.</p>   <p>Chrome will now default to HTTPS for most typed navigations that don’t specify a protocol<sup>2</sup>. HTTPS is the more secure and most <a href=\"https://transparencyreport.google.com/https/overview?hl=en\" target=\"_blank\">widely used scheme</a> in Chrome on all major platforms. In addition to being a clear security and privacy improvement, this change improves the initial loading speed of sites that support HTTPS, since Chrome will connect directly to the HTTPS endpoint without needing to be redirected from <i>http://</i> to <i>https://</i>. For sites that don’t yet support HTTPS, Chrome will fall back to HTTP when the HTTPS attempt fails (including when there are certificate errors, such as name mismatch or untrusted self-signed certificate, or connection errors, such as DNS resolution failure). This change is rolling out initially on Chrome Desktop and Chrome for Android in version 90, with a release for Chrome on iOS following soon after.</p>   <div class=\"separator\" style=\"clear: both;\"><a href=\"https://1.bp.blogspot.com/-g-M0w0sGYf4/YFnptLlig8I/AAAAAAAABbA/x033CnffCdc-s1J9AM-jk9ydiQPj_9CxQCLcBGAsYHQ/s1080/Chromium_HTTPS_Blog.gif\" style=\"display: block; padding: 0em 0px; text-align: center;\"><img alt=\"\" border=\"0\" data-original-height=\"1080\" data-original-width=\"1080\" height=\"514\" src=\"https://1.bp.blogspot.com/-g-M0w0sGYf4/YFnptLlig8I/AAAAAAAABbA/x033CnffCdc-s1J9AM-jk9ydiQPj_9CxQCLcBGAsYHQ/w514-h514/Chromium_HTTPS_Blog.gif\" width=\"500\" /></a></div> <p>HTTPS protects users by encrypting traffic sent over the network, so that sensitive information users enter on websites cannot be intercepted or modified by attackers or eavesdroppers. Chrome is invested in ensuring that HTTPS is the default protocol for the web, and this change is one more step towards ensuring Chrome always uses secure connections by default.</p> <p style=\"line-height: normal;\">  <span style=\"font-size: small;\">    <sup>1</sup> One notable exception to this is any site in the <a href=\"https://hstspreload.org/\" target=\"_blank\">HSTS preload list</a>, which Chrome will always default to HTTPS.<br />\t<sup>2</sup> IP addresses, single label domains, and reserved hostnames such as test/ or localhost/ will continue defaulting to HTTP.   </span></p> <span class=\"post-author\">Posted by Shweta Panditrao and Mustafa Emre Acer, Chrome team</span>",
        "contentSnippet": "Starting in version 90, Chrome’s address bar will use https:// by default, improving privacy and even loading speed for users visiting websites that support HTTPS. Chrome users who navigate to websites by manually typing a URL often don’t include “http://” or “https://”. For example, users often type “example.com” instead of “https://example.com” in the address bar. In this case, if it was a user’s first visit to a website, Chrome would previously choose http:// as the default protocol1. This was a practical default in the past, when much of the web did not support HTTPS.\n   \nChrome will now default to HTTPS for most typed navigations that don’t specify a protocol2. HTTPS is the more secure and most widely used scheme in Chrome on all major platforms. In addition to being a clear security and privacy improvement, this change improves the initial loading speed of sites that support HTTPS, since Chrome will connect directly to the HTTPS endpoint without needing to be redirected from http:// to https://. For sites that don’t yet support HTTPS, Chrome will fall back to HTTP when the HTTPS attempt fails (including when there are certificate errors, such as name mismatch or untrusted self-signed certificate, or connection errors, such as DNS resolution failure). This change is rolling out initially on Chrome Desktop and Chrome for Android in version 90, with a release for Chrome on iOS following soon after.\n   \n\n HTTPS protects users by encrypting traffic sent over the network, so that sensitive information users enter on websites cannot be intercepted or modified by attackers or eavesdroppers. Chrome is invested in ensuring that HTTPS is the default protocol for the web, and this change is one more step towards ensuring Chrome always uses secure connections by default.\n       1 One notable exception to this is any site in the HSTS preload list, which Chrome will always default to HTTPS.\n\t2 IP addresses, single label domains, and reserved hostnames such as test/ or localhost/ will continue defaulting to HTTP.   \n Posted by Shweta Panditrao and Mustafa Emre Acer, Chrome team",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-6341327188711554390",
        "isoDate": "2021-03-23T15:00:00.002Z"
    },
    {
        "title": "Mitigating Side-Channel Attacks",
        "link": "http://blog.chromium.org/2021/03/mitigating-side-channel-attacks.html",
        "pubDate": "2021-03-12T14:00:00.002Z",
        "author": "Chromium Blog",
        "content": "<p>The web platform relies on the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Origin\" target=\"_blank\">origin</a> as a fundamental security boundary, and browsers do a pretty good job at preventing <i>explicit</i> leakage of data from one origin to another. Attacks like <a href=\"https://spectreattack.com/\" target=\"_blank\">Spectre</a>, however, show that we still have work to do to mitigate <i>implicit</i> data leakage. The side-channels exploited through these attacks prove that <a href=\"https://chromium.googlesource.com/chromium/src/+/master/docs/security/side-channel-threat-model.md#introduction\" target=\"_blank\">attackers can read any data which enters a process hosting that attackers' code</a>. These attacks are <a href=\"https://security.googleblog.com/2021/03/a-spectre-proof-of-concept-for-spectre.html\">quite practical</a> today, and pose a real risk to users.</p> <p>Our goal must be to ensure that sensitive data doesn't unexpectedly enter an attacker's process. Browsers shoulder a large chunk of this responsibility: Chromium's <a href=\"https://www.chromium.org/Home/chromium-security/site-isolation\" target=\"_blank\">Site Isolation</a> can separate the sites you visit into distinct OS-level processes, <a href=\"https://chromium.googlesource.com/chromium/src/+/master/services/network/cross_origin_read_blocking_explainer.md\" target=\"_blank\">cross-origin read blocking</a> prevents attackers from loading a subset of otherwise-vulnerable cross-origin resources, and APIs that substantially increase attackers' bandwidth (like <span style=\"font-family: courier;\"><a href=\"https://developer.chrome.com/blog/enabling-shared-array-buffer/#cross-origin-isolation\" target=\"_blank\">SharedArrayBuffer</a></span>) are being locked to <a href=\"https://web.dev/cross-origin-isolation-guide/\" target=\"_blank\">cross-origin isolated contexts</a>. This last mechanism, however, points in the direction of work that browsers can't do on their own.</p> <p>Web developers know their applications intimately, and can make informed decisions about each page's and resource's risk of exposure. To defend users' data against exfiltration, web developers must step in, evaluate resources they host, and instruct browsers to isolate those resources accordingly. At a high-level, this defense consists of:</p> <p></p><ol style=\"text-align: left;\">  <li><b>Deciding when to respond to requests</b> by examining incoming headers, paying special attention to the <span style=\"font-family: courier;\">Origin</span> header on the one hand, and various <a href=\"https://web.dev/fetch-metadata/\" target=\"_blank\"><span style=\"font-family: courier;\">Sec-Fetch-</span> prefixed headers</a> on the other.</li>     <li><b>Restricting attackers' ability to load resources as a subresource</b> by setting a <a href=\"https://resourcepolicy.fyi/\" target=\"_blank\">cross-origin resource policy</a> of <span style=\"font-family: courier;\">same-origin</span> (opening up to <span style=\"font-family: courier;\">same-site</span> or <span style=\"font-family: courier;\">cross-origin</span> only when necessary).</li>     <li><b>Restricting attackers' ability to frame resources as a document</b> by opting into framing protections via <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\" target=\"_blank\"><span style=\"font-family: courier;\">X-Frame-Options</span></a>: <span style=\"font-family: courier;\">SAMEORIGIN</span> or CSP’s more granular <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors\" target=\"_blank\"><span style=\"font-family: courier;\">frame-ancestors</span></a> directive: for example, <span style=\"font-family: courier;\">frame-ancestors 'self' https://trusted.embedder.</span></li>     <li><b>Restricting attackers' ability to reference your application's windows</b> by setting a <a href=\"https://web.dev/coop-coep/\" target=\"_blank\">cross-origin opener policy</a>. In the best case, you can default to a restrictive <span style=\"font-family: courier;\">same-origin</span> value, opening up to <span style=\"font-family: courier;\">same-origin-allow-popups</span> or <span style=\"font-family: courier;\">unsafe-none</span> only if necessary.</li>     <li><b>Preventing MIME-type confusion attacks</b> and increasing the robustness of passive defenses like <a href=\"https://developers.google.com/web/updates/2018/07/site-isolation#corb\" target=\"_blank\">cross-origin read blocking</a> by setting correct <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type\" target=\"_blank\"><span style=\"font-family: courier;\">Content-Type</span></a> headers, and globally asserting <span style=\"font-family: courier;\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options\" target=\"_blank\">X-Content-Type-Options</a>: nosniff.</span></li></ol><p></p> <p>Together, these various defenses help all browsers offer some degree of process-level protection for users' data, whether or not Site Isolation is available.</p> <p>To find out more about employing these defenses, check out <a href=\"https://w3c.github.io/webappsec-post-spectre-webdev/\" target=\"_blank\">Post-Spectre Web Development</a>. It includes practical examples that explain in more detail how the security primitives discussed above apply to resources you might have on your sites.</p> <p>These are useful steps you can take <i>today</i> to protect your origin against implicit data leaks. Looking forward, we hope to help the web <a href=\"https://speakerdeck.com/mikewest/isolation-by-default\" target=\"_blank\">shift to safer defaults</a> which protect users against these attacks without requiring developer action.</p> <span class=\"post-author\">Posted by Mike West, on behalf of Chrome's web platform security team</span>",
        "contentSnippet": "The web platform relies on the origin as a fundamental security boundary, and browsers do a pretty good job at preventing explicit leakage of data from one origin to another. Attacks like Spectre, however, show that we still have work to do to mitigate implicit data leakage. The side-channels exploited through these attacks prove that attackers can read any data which enters a process hosting that attackers' code. These attacks are quite practical today, and pose a real risk to users.\n Our goal must be to ensure that sensitive data doesn't unexpectedly enter an attacker's process. Browsers shoulder a large chunk of this responsibility: Chromium's Site Isolation can separate the sites you visit into distinct OS-level processes, cross-origin read blocking prevents attackers from loading a subset of otherwise-vulnerable cross-origin resources, and APIs that substantially increase attackers' bandwidth (like SharedArrayBuffer) are being locked to cross-origin isolated contexts. This last mechanism, however, points in the direction of work that browsers can't do on their own.\n Web developers know their applications intimately, and can make informed decisions about each page's and resource's risk of exposure. To defend users' data against exfiltration, web developers must step in, evaluate resources they host, and instruct browsers to isolate those resources accordingly. At a high-level, this defense consists of:\n \n  \nDeciding when to respond to requests by examining incoming headers, paying special attention to the Origin header on the one hand, and various Sec-Fetch- prefixed headers on the other.\n     \nRestricting attackers' ability to load resources as a subresource by setting a cross-origin resource policy of same-origin (opening up to same-site or cross-origin only when necessary).\n     \nRestricting attackers' ability to frame resources as a document by opting into framing protections via X-Frame-Options: SAMEORIGIN or CSP’s more granular frame-ancestors directive: for example, frame-ancestors 'self' https://trusted.embedder.\n     \nRestricting attackers' ability to reference your application's windows by setting a cross-origin opener policy. In the best case, you can default to a restrictive same-origin value, opening up to same-origin-allow-popups or unsafe-none only if necessary.\n     \nPreventing MIME-type confusion attacks and increasing the robustness of passive defenses like cross-origin read blocking by setting correct Content-Type headers, and globally asserting X-Content-Type-Options: nosniff.\n\n \nTogether, these various defenses help all browsers offer some degree of process-level protection for users' data, whether or not Site Isolation is available.\n To find out more about employing these defenses, check out Post-Spectre Web Development. It includes practical examples that explain in more detail how the security primitives discussed above apply to resources you might have on your sites.\n These are useful steps you can take today to protect your origin against implicit data leaks. Looking forward, we hope to help the web shift to safer defaults which protect users against these attacks without requiring developer action.\n Posted by Mike West, on behalf of Chrome's web platform security team",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-5555956832006267068",
        "isoDate": "2021-03-12T14:00:00.002Z"
    },
    {
        "title": "Chrome 90 Beta: AV1 Encoder for WebRTC, New Origin Trials, and More",
        "link": "http://blog.chromium.org/2021/03/chrome-90-beta-av1-encoder-for-webrtc.html",
        "pubDate": "2021-03-11T22:38:00.005Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D90\">ChromeStatus.com</a>. Chrome 90 is beta as of March 11, 2021.</p> <h1>AV1 Encoder</h1><p>An <a href=\"https://www.chromestatus.com/feature/6206321818861568\">AV1 encoder</a> is shipping in Chrome desktop that is specifically optimized for video conferencing with WebRTC integration. The benefits of AV1 include:</p> <ul><li>Better compression efficiency than other types of video encoding, reducing bandwidth consumption and improve visual quality</li><li>Enabling video for users on very low bandwidth networks (offering video at 30kbps and lower)</li><li>Significant screen sharing efficiency improvements over VP9 and other codecs.</li></ul> <p>This is an important addition to WebRTC especially since it recently became an <a href=\"https://web.dev/webrtc-standard-announcement/\">official W3C and IETF standard</a>.</p> <h1>Origin Trials</h1><p>This version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the <a href=\"https://developer.chrome.com/origintrials/#/trials/active\">Chrome Origin Trials dashboard</a>. To learn more about origin trials in Chrome, visit the <a href=\"https://web.dev/origin-trials/\">Origin Trials Guide for Web Developers</a>. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/origin-trials/\">Microsoft Edge Origin Trials Developer Console</a>. </p> <h2>New Origin Trials</h2> <h3>getCurrentBrowsingContextMedia()</h3> <p>The <a href=\"https://developer.chrome.com/origintrials/#/view_trial/3654671097611157505\">mediaDevices.getCurrentBrowsingContextMedia() method</a> allows capturing a MediaStream with the current tab's video (and potentially audio), similar to getDisplayMedia(). Unlike getDisplayMedia(), calling this new method will eventually present the user with a simple accept/reject dialog box. If the user accepts, the current tab is captured. However, this will require some additional security measures which are still being finalized. Until then, or if the call is made with these measures absent, a dialog is displayed to the user that allows the selection of any source, but highlights the option of the current tab (whereas normally getDisplayMedia highlights the option of entire-screen).</p> <h3>MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)</h3><p>An API for <a href=\"https://www.chromestatus.com/feature/5499415634640896\">manipulating raw media carried by MediaStreamTracks</a> such as the output of a camera, microphone, screen capture, or the decoder part of a codec and the input to the decoder part of a codec. It uses WebCodecs interfaces to represent raw media frames and exposes them using streams, similar to the way the WebRTC Insertable Streams API exposes encoded data from RTCPeerConnections. This is intended to support use cases such as:</p> <ul><li><a href=\"https://www.w3.org/TR/webrtc-nv-use-cases/#funnyhats*\">Funny Hats</a>: Refers to manipulation of media either before encoding and after decoding to provide effects such as background removal, funny hats, voice effects.</li><li><a href=\"https://www.w3.org/TR/webrtc-nv-use-cases/#machinelearning*\">Machine Learning</a>: Refers to applications such as real-time object identification/annotation.</li></ul> <p>This origin trial is expected to run through Chrome 92.</p> <h3>Subresource Loading with Web Bundles</h3><p><a href=\"https://developer.chrome.com/origintrials/#/view_trial/-6307291278132379647\">Subresource loading with Web Bundles</a>&nbsp;provides a new approach to loading a large number of resources efficiently using a format that allows multiple resources to be bundled., e.g. Web Bundles.</p> <p>The output of JavaScript bundlers (e.g. webpack) doesn't interact well with browsers. They are good tools but:</p> <ul><li>Their output can't interact with the HTTP cache at any finer grain than the bundle itself (not solved with this origin trial). This can make them incompatible with new requirements like dynamic bundling (e.g. small edit with tree shaking could invalidate everything).</li><li>They force compilation and execution to wait until all bytes have arrived. Ideally loading multiple subresources should be able to utilize full streaming and parallelization, but that's not possible if all resources are bundled as one javascript. (This origin trial allows compilation to proceed in parallel. For JavaScript modules, execution still needs to wait for the entire tree due to the current deterministic execution model).</li><li>They can require non-JS resources like stylesheets and images to be encoded as JS strings, which forces them to be parsed twice and can increase their size. This origin trial allows those resources to be loaded in their original form.</li></ul> <p>This origin trial also allows a bundle to include the source for an opaque-origin iframe as <code>urn:uuid:</code> resources. The scheme for these resources is expected to change in Chrome 91.</p> <p>This origin trial is expected to run through Chrome 92.</p><h3>WebAssembly Exception Handling</h3><p>WebAssembly&nbsp;<a href=\"https://developer.chrome.com/origintrials/#/view_trial/2393663201947418625\">now provides exception handling</a>&nbsp;support. Exception handling allows code to break control flow when an exception is thrown. The exception can be any that is known by the WebAssembly module, or it may be an unknown exception that was thrown by a called imported function. This origin trial is expected to run through Chrome 94.</p>  <h2>Completed Origin Trials</h2><p>The following features, previously in a Chrome origin trial, are now enabled by default.</p> <h3>WebXR AR Lighting Estimation</h3><p><a href=\"https://www.chromestatus.com/feature/5704707957850112\">Lighting estimation</a> allows sites to query for estimates of the environmental lighting conditions within WebXR sessions. This exposes both spherical harmonics representing the ambient lighting, as well as a cubemap texture representing \"reflections\". Adding Lighting Estimation can make your models feel more natural and like they \"fit\" better with the user's environment.</p> <h1>Other Features in this Release</h1> <h3>CSS</h3> <h3>aspect-ratio Interpolation</h3><p>The <a href=\"https://www.chromestatus.com/feature/5682100885782528\"><code>aspect-ratio</code> property</a> allows for automatically computing the other dimension if only one of width or height is specified on any element. This property was originally launched as non-interpolable (meaning that it would snap to the target value) when animated. This feature provides smooth interpolation from one aspect ratio to another.</p> <h3>Custom State Pseudo Classes</h3><p>Custom elements <a href=\"https://www.chromestatus.com/feature/6537562418053120\">now expose their states</a> via the state CSS pseudo class. Built-in elements have states that can change over time depending on user interaction and other factors, which are exposed to web authors through pseudo classes. For example, some form controls have the \"invalid\" state, which is exposed through the :invalid pseudo class. Since custom elements also have states it makes sense to expose their states in a manner similar to built-in elements.</p> <h3>Implement 'auto' value for appearance and -webkit-appearance</h3><p>The default values of CSS property <code>appearance</code> and <code>-webkit-appearance</code> for the following form controls are changed to <code>'auto'</code>.</p> <ul><li><code>&lt;input type=color&gt;</code> and <code>&lt;select&gt;</code></li><li>Android only: <code>&lt;input type=date&gt;</code>, <code>&lt;input type=datetime-local&gt;</code>, <code>&lt;input type=month&gt;</code>, <code>&lt;input type=time&gt;</code>, and <code>&lt;input type=week&gt;</code></li></ul><p>Note that the default rendering of these controls are not changed.</p> <h3>overflow: clip Property</h3><p>The <a href=\"https://www.chromestatus.com/feature/5638444178997248\"><code>clip</code> value for <code>overflow</code></a> results in a box's content being clipped to the box's overflow clip edge. In addition, no scrolling interface is provided, and the content cannot be scrolled by the user or programmatically. Additionally the box is not considered a scroll container, and does not start a new formatting context. As a result, this value has better performance than <code>overflow: hidden</code>.</p> <h3>overflow-clip-margin Property</h3><p>The <a href=\"https://www.chromestatus.com/feature/5638444178997248\"><code>overflow-clip-margin</code> property</a> enables specifying how far outside the bounds an element is allowed to paint before being clipped. It also allows the developer to expand the clip border. This is particularly useful for cases where there is ink overflow that should be visible.</p> <h2>Permissions-Policy Header</h2><p>The <code>Permissions-Policy</code> HTTP header <a href=\"https://www.chromestatus.com/feature/5745992911552512\">replaces the existing <code>Feature-Policy</code> header</a> for controlling delegation of permissions and powerful features. The header allows sites to more tightly restrict which origins can be granted access to features.</p> <p>The <a href=\"https://developers.google.com/web/updates/2018/06/feature-policy#js\">Feature Policy API</a>, introduced in Chrome 74, was recently renamed to \"Permissions Policy\", and the HTTP header has been renamed along with it. At the same time, the community has settled on a new syntax, based on <a href=\"https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html\">structured field values for HTTP</a>.</p> <h2>Protect application/x-protobuffer via Cross-Origin-Read-Blocking </h2><p><a href=\"https://www.chromestatus.com/feature/5670287242690560\">Protect <code>application/x-protobuffer</code> from speculative execution</a> attacks by adding it to the list of never sniffed MIME types used by <code>Cross-Origin-Read-Blocking</code>. <code>application/x-protobuf</code> is already protected as a never sniffed mime type.  <code>application/x-protobuffer</code> is another commonly used MIME type that is defined as an <code>\"ALT_CONTENT_TYPE\"</code> by the protobuf library. </p> <h2>Seeking Past the End of a File in the File System Access API</h2><p>When data is passed to <code>FileSystemWritableFileStream.write()</code> that would extend past the end of the file, <a href=\"https://www.chromestatus.com/feature/6556060494069760\">the file is now extended by writing <code>0x00</code> (<code>NUL</code>)</a>. This enables creating sparse files and greatly simplifies saving content to a file when the data to be written is received out of order.<br />Without this functionality, applications that receive file contents out of order (for example, BiTtorrent downloads) would have to manually resize the file either ahead of time or when needed during writing.</p> <h2>StaticRange Constructor</h2><p>Currently, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Range\"><code>Range</code></a> is the only constructible range type available to web authors. However, <code>Range</code> objects are \"live\" and maintaining them can be expensive. For every tree change, all affected <code>Range</code> objects need to be updated. <a href=\"https://www.chromestatus.com/feature/5676695065460736\">The new <code>StaticRange</code> objects</a> are not live and represent a lightweight range type that is not subject to the same maintenance cost as <code>Range</code>. Making <code>StaticRange</code> constructible allows web authors to use them for ranges that do not need to be updated on every DOM tree change.</p> <h2>Support Specifying Width and Height on &lt;source&gt; Elements for &lt;picture&gt;</h2><p>The <code>&lt;source&gt;</code> element <a href=\"https://www.chromestatus.com/feature/5737185317748736\">now supports <code>width</code> and <code>height</code> properties</a> when used inside a <code>&lt;picture&gt;</code> element. This allows Chrome to compute an aspect ratio for <code>&lt;picture&gt;</code> elements. This matches similar behavior for <code>&lt;img&gt;</code>, <code>&lt;canvas&gt;</code> and <code>&lt;video&gt;</code> elements.</p> <h2>WebAudio: OscillatorOptions.periodicWave is Not Nullable</h2><p>It is <a href=\"https://www.chromestatus.com/feature/5086267630944256\">no longer possible to set periodicWave to null</a> when creating a new <code>OscillatorNode</code> object. This value is set on the options object passed to the <code>OscillatorNode()</code> constructor. The WebAudio spec doesn't allow setting this value to null. Chrome now matches both the spec and Firefox. </p> <h1>JavaScript</h1><p>This version of Chrome incorporates version 9.0 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h2>Relative Indexing Method for Array, String, and TypedArrays</h2><p>Array, String, and TypedArray <a href=\"https://www.chromestatus.com/feature/6123640410079232\">now support the <code>at()</code> method</a>, which supports relative indexing with negative numbers. For example, the code below returns the last item in the given array.</p> <pre>let arr = [1,2,3,4];<br />arr.at(-1);<br /></pre> <h1>Deprecations, and Removals</h1><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h2>Remove Content Security Policy Directive 'plugin-types'</h2><p>The <a href=\"https://www.chromestatus.com/feature/5742693948850176\">'plugin-types' directive allows developers to restrict</a> which types of plugin can be loaded via <code>&lt;embed&gt;</code> or <code>&lt;object&gt;</code> html elements. This allowed developers to block Flash in their pages. Since Flash support has been discontinued, there is no longer any need for this policy directive.</p> <h2>Remove WebRTC RTP Data Channels</h2><p>Chrome has <a href=\"https://www.chromestatus.com/feature/6485681910054912\">removed support for the non-standard RTP data channels</a> in WebRTC. Users should use the standard SCTP-based data channels instead.</p> <h2>Return Empty for navigator.plugins and navigator.mimeTypes</h2><p>Chrome <a href=\"https://www.chromestatus.com/feature/5741884322349056\">now returns empty for <code>navigator.plugins</code> and <code>navigator.mimeTypes</code></a>. With the removal of Flash, there is no longer the need to return anything for these properties. <br /><br /></p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 90 is beta as of March 11, 2021.\n AV1 Encoder\nAn AV1 encoder is shipping in Chrome desktop that is specifically optimized for video conferencing with WebRTC integration. The benefits of AV1 include:\n \nBetter compression efficiency than other types of video encoding, reducing bandwidth consumption and improve visual quality\nEnabling video for users on very low bandwidth networks (offering video at 30kbps and lower)\nSignificant screen sharing efficiency improvements over VP9 and other codecs.\n \nThis is an important addition to WebRTC especially since it recently became an official W3C and IETF standard.\n Origin Trials\nThis version of Chrome introduces the origin trials described below. Origin trials allow you to try new features and give feedback on usability, practicality, and effectiveness to the web standards community. To register for any of the origin trials currently supported in Chrome, including the ones described below, visit the Chrome Origin Trials dashboard. To learn more about origin trials in Chrome, visit the Origin Trials Guide for Web Developers. Microsoft Edge runs its own origin trials separate from Chrome. To learn more, see the Microsoft Edge Origin Trials Developer Console. \n New Origin Trials\n getCurrentBrowsingContextMedia()\n The mediaDevices.getCurrentBrowsingContextMedia() method allows capturing a MediaStream with the current tab's video (and potentially audio), similar to getDisplayMedia(). Unlike getDisplayMedia(), calling this new method will eventually present the user with a simple accept/reject dialog box. If the user accepts, the current tab is captured. However, this will require some additional security measures which are still being finalized. Until then, or if the call is made with these measures absent, a dialog is displayed to the user that allows the selection of any source, but highlights the option of the current tab (whereas normally getDisplayMedia highlights the option of entire-screen).\n MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)\nAn API for manipulating raw media carried by MediaStreamTracks such as the output of a camera, microphone, screen capture, or the decoder part of a codec and the input to the decoder part of a codec. It uses WebCodecs interfaces to represent raw media frames and exposes them using streams, similar to the way the WebRTC Insertable Streams API exposes encoded data from RTCPeerConnections. This is intended to support use cases such as:\n \nFunny Hats: Refers to manipulation of media either before encoding and after decoding to provide effects such as background removal, funny hats, voice effects.\nMachine Learning: Refers to applications such as real-time object identification/annotation.\n \nThis origin trial is expected to run through Chrome 92.\n Subresource Loading with Web Bundles\nSubresource loading with Web Bundles provides a new approach to loading a large number of resources efficiently using a format that allows multiple resources to be bundled., e.g. Web Bundles.\n The output of JavaScript bundlers (e.g. webpack) doesn't interact well with browsers. They are good tools but:\n \nTheir output can't interact with the HTTP cache at any finer grain than the bundle itself (not solved with this origin trial). This can make them incompatible with new requirements like dynamic bundling (e.g. small edit with tree shaking could invalidate everything).\nThey force compilation and execution to wait until all bytes have arrived. Ideally loading multiple subresources should be able to utilize full streaming and parallelization, but that's not possible if all resources are bundled as one javascript. (This origin trial allows compilation to proceed in parallel. For JavaScript modules, execution still needs to wait for the entire tree due to the current deterministic execution model).\nThey can require non-JS resources like stylesheets and images to be encoded as JS strings, which forces them to be parsed twice and can increase their size. This origin trial allows those resources to be loaded in their original form.\n \nThis origin trial also allows a bundle to include the source for an opaque-origin iframe as urn:uuid: resources. The scheme for these resources is expected to change in Chrome 91.\n This origin trial is expected to run through Chrome 92.\nWebAssembly Exception Handling\nWebAssembly now provides exception handling support. Exception handling allows code to break control flow when an exception is thrown. The exception can be any that is known by the WebAssembly module, or it may be an unknown exception that was thrown by a called imported function. This origin trial is expected to run through Chrome 94.\n  \nCompleted Origin Trials\nThe following features, previously in a Chrome origin trial, are now enabled by default.\n WebXR AR Lighting Estimation\nLighting estimation allows sites to query for estimates of the environmental lighting conditions within WebXR sessions. This exposes both spherical harmonics representing the ambient lighting, as well as a cubemap texture representing \"reflections\". Adding Lighting Estimation can make your models feel more natural and like they \"fit\" better with the user's environment.\n Other Features in this Release\n CSS\n aspect-ratio Interpolation\nThe aspect-ratio property allows for automatically computing the other dimension if only one of width or height is specified on any element. This property was originally launched as non-interpolable (meaning that it would snap to the target value) when animated. This feature provides smooth interpolation from one aspect ratio to another.\n Custom State Pseudo Classes\nCustom elements now expose their states via the state CSS pseudo class. Built-in elements have states that can change over time depending on user interaction and other factors, which are exposed to web authors through pseudo classes. For example, some form controls have the \"invalid\" state, which is exposed through the :invalid pseudo class. Since custom elements also have states it makes sense to expose their states in a manner similar to built-in elements.\n Implement 'auto' value for appearance and -webkit-appearance\nThe default values of CSS property appearance and -webkit-appearance for the following form controls are changed to 'auto'.\n \n<input type=color> and <select>\nAndroid only: <input type=date>, <input type=datetime-local>, <input type=month>, <input type=time>, and <input type=week>\n\nNote that the default rendering of these controls are not changed.\n overflow: clip Property\nThe clip value for overflow results in a box's content being clipped to the box's overflow clip edge. In addition, no scrolling interface is provided, and the content cannot be scrolled by the user or programmatically. Additionally the box is not considered a scroll container, and does not start a new formatting context. As a result, this value has better performance than overflow: hidden.\n overflow-clip-margin Property\nThe overflow-clip-margin property enables specifying how far outside the bounds an element is allowed to paint before being clipped. It also allows the developer to expand the clip border. This is particularly useful for cases where there is ink overflow that should be visible.\n Permissions-Policy Header\nThe Permissions-Policy HTTP header replaces the existing Feature-Policy header for controlling delegation of permissions and powerful features. The header allows sites to more tightly restrict which origins can be granted access to features.\n The Feature Policy API, introduced in Chrome 74, was recently renamed to \"Permissions Policy\", and the HTTP header has been renamed along with it. At the same time, the community has settled on a new syntax, based on structured field values for HTTP.\n Protect application/x-protobuffer via Cross-Origin-Read-Blocking \nProtect application/x-protobuffer from speculative execution attacks by adding it to the list of never sniffed MIME types used by Cross-Origin-Read-Blocking. application/x-protobuf is already protected as a never sniffed mime type.  application/x-protobuffer is another commonly used MIME type that is defined as an \"ALT_CONTENT_TYPE\" by the protobuf library. \n Seeking Past the End of a File in the File System Access API\nWhen data is passed to FileSystemWritableFileStream.write() that would extend past the end of the file, the file is now extended by writing 0x00 (NUL). This enables creating sparse files and greatly simplifies saving content to a file when the data to be written is received out of order.\nWithout this functionality, applications that receive file contents out of order (for example, BiTtorrent downloads) would have to manually resize the file either ahead of time or when needed during writing.\n StaticRange Constructor\nCurrently, Range is the only constructible range type available to web authors. However, Range objects are \"live\" and maintaining them can be expensive. For every tree change, all affected Range objects need to be updated. The new StaticRange objects are not live and represent a lightweight range type that is not subject to the same maintenance cost as Range. Making StaticRange constructible allows web authors to use them for ranges that do not need to be updated on every DOM tree change.\n Support Specifying Width and Height on <source> Elements for <picture>\nThe <source> element now supports width and height properties when used inside a <picture> element. This allows Chrome to compute an aspect ratio for <picture> elements. This matches similar behavior for <img>, <canvas> and <video> elements.\n WebAudio: OscillatorOptions.periodicWave is Not Nullable\nIt is no longer possible to set periodicWave to null when creating a new OscillatorNode object. This value is set on the options object passed to the OscillatorNode() constructor. The WebAudio spec doesn't allow setting this value to null. Chrome now matches both the spec and Firefox. \n JavaScript\nThis version of Chrome incorporates version 9.0 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete list of recent features in the V8 release notes.\n Relative Indexing Method for Array, String, and TypedArrays\nArray, String, and TypedArray now support the at() method, which supports relative indexing with negative numbers. For example, the code below returns the last item in the given array.\n let arr = [1,2,3,4];\narr.at(-1);\n \nDeprecations, and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n Remove Content Security Policy Directive 'plugin-types'\nThe 'plugin-types' directive allows developers to restrict which types of plugin can be loaded via <embed> or <object> html elements. This allowed developers to block Flash in their pages. Since Flash support has been discontinued, there is no longer any need for this policy directive.\n Remove WebRTC RTP Data Channels\nChrome has removed support for the non-standard RTP data channels in WebRTC. Users should use the standard SCTP-based data channels instead.\n Return Empty for navigator.plugins and navigator.mimeTypes\nChrome now returns empty for navigator.plugins and navigator.mimeTypes. With the removal of Flash, there is no longer the need to return anything for these properties.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-6661433624352009101",
        "isoDate": "2021-03-11T22:38:00.005Z"
    },
    {
        "title": "Advanced memory management and more performance improvements in M89",
        "link": "http://blog.chromium.org/2021/03/advanced-memory-management-and-more.html",
        "pubDate": "2021-03-11T17:27:00.001Z",
        "author": "Chromium Blog",
        "content": "<div>Boosting performance while adding features, functionality, and improving security, requires deep and continuous investment. Today’s post is the first in a series this year that will go into more technical detail about Chrome's ongoing efforts around performance. In this release, we’ve dug deep into the core of Chrome, upgrading how we allocate and discard memory, and even how we build, package, and run Chrome, to make today’s Chrome even faster and more memory efficient.&nbsp;</div><div><br /></div><div><br /></div><div><br /></div><h3 style=\"text-align: left;\">Improving memory management</h3><div>In Chrome M89, we’re seeing significant memory savings on Windows--up to 22% in the browser process, 8% in the renderer, and 3% in the GPU. Even more than that, we’ve improved browser responsiveness by up to 9%. We’ve achieved this by using <a href=\"https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md\" target=\"_blank\">PartitionAlloc</a>, our own advanced memory allocator, which is optimized for low allocation latency, space efficiency, and security. For some time now, PartitionAlloc has been used extensively within Blink, our renderer codebase. Starting in M89, we’ve upgraded Chrome on Android and 64-bit Windows to use PartitionAlloc everywhere (by intercepting malloc).</div><div><br /></div><div>In addition to improving how we allocate memory, Chrome is now smarter about using (and discarding) memory. Chrome now reclaims up to 100MiB per tab, which is more than 20% on some popular sites, by discarding memory that the foreground tab is not actively using, such as big images you’ve scrolled off screen. Chrome is also shrinking its memory footprint in background tabs on macOS, something we’ve been doing on other platforms for a while. We’re seeing up to 8% memory savings, which is more than 1GiB in some cases!</div><div><br /></div><div>Finally, with more data from the field on <a href=\"https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html\" target=\"_blank\">tab throttling</a>, we’re seeing up to 65% improvement on Apple Energy Impact score for tabs in the background, keeping your Mac cooler and those fans quiet.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><h3 style=\"text-align: left;\">Build, packaging, and runtime improvements</h3><div>Focusing on Chrome for Android, we have a uniquely challenging job of building a great browser for every single variant of Android device. In this release we’re taking advantage of some packaging and runtime optimizations to deliver better performance in the Chrome that is in your pocket.</div><div><br /></div><div>Some new Play and Android capabilities allowed us to repackage Chrome on Android, and we’re seeing fewer crashes due to resource exhaustion, a 5% improvement in memory usage, 7.5% faster startup times, and up to 2% faster page loads. <a href=\"https://developer.android.com/guide/app-bundle\" target=\"_blank\">Android App Bundles</a> allow the Play Store to generate optimized APKs for each user’s device configuration, and allows packaging code and resources in split APKs, which are installed alongside the base APK. And an Android O feature, <a href=\"https://developer.android.com/reference/android/R.attr#isolatedSplits\" target=\"_blank\">isolatedSplits</a>, allows these feature splits to be loaded on demand, reducing Chrome’s overall startup cost.</div><div><br /></div><div>For those of you who picked up the latest Android devices (Android Q+ and 8GB+ of RAM), we’ve rebuilt Chrome as a 64-bit binary, giving you a more stable Chrome that is up to 8.5% faster to load pages and 28% smoother when it comes to scrolling and input latency.</div><div><br /></div><div>Finally, we’ve built a way for Chrome on Android to start up 13% faster: Freeze-Dried Tabs. Chrome now saves a lightweight version of your tabs that are similar in size to a screenshot, but support scrolling, zooming, and tapping on links. We use these Freeze-Dried Tabs at startup while the actual tab loads in the background, getting you to your pages faster. See it in action below:</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"BLOG_video_class\" height=\"327\" src=\"https://www.youtube.com/embed/65Gv8phJarI\" width=\"475\" youtube-src-id=\"65Gv8phJarI\"></iframe></div><br /><div><br /></div><div>Our teams are always working hard to bring you the fastest and most powerful browser on every one of your devices. We’re very excited to bring you these performance improvements and have much more to come, so stay tuned.</div><div><br /></div><div>Posted by&nbsp;Mark Chang, Chrome Product Manager</div><div><br /></div><div><i>Data source for all statistics: <a href=\"https://www.google.com/chrome/privacy/whitepaper.html#usagestats\" target=\"_blank\">Real-world data</a> anonymously aggregated from Chrome clients.</i></div><div><br /></div>",
        "contentSnippet": "Boosting performance while adding features, functionality, and improving security, requires deep and continuous investment. Today’s post is the first in a series this year that will go into more technical detail about Chrome's ongoing efforts around performance. In this release, we’ve dug deep into the core of Chrome, upgrading how we allocate and discard memory, and even how we build, package, and run Chrome, to make today’s Chrome even faster and more memory efficient. \n\n\n\n\n\nImproving memory management\nIn Chrome M89, we’re seeing significant memory savings on Windows--up to 22% in the browser process, 8% in the renderer, and 3% in the GPU. Even more than that, we’ve improved browser responsiveness by up to 9%. We’ve achieved this by using PartitionAlloc, our own advanced memory allocator, which is optimized for low allocation latency, space efficiency, and security. For some time now, PartitionAlloc has been used extensively within Blink, our renderer codebase. Starting in M89, we’ve upgraded Chrome on Android and 64-bit Windows to use PartitionAlloc everywhere (by intercepting malloc).\n\n\nIn addition to improving how we allocate memory, Chrome is now smarter about using (and discarding) memory. Chrome now reclaims up to 100MiB per tab, which is more than 20% on some popular sites, by discarding memory that the foreground tab is not actively using, such as big images you’ve scrolled off screen. Chrome is also shrinking its memory footprint in background tabs on macOS, something we’ve been doing on other platforms for a while. We’re seeing up to 8% memory savings, which is more than 1GiB in some cases!\n\n\nFinally, with more data from the field on tab throttling, we’re seeing up to 65% improvement on Apple Energy Impact score for tabs in the background, keeping your Mac cooler and those fans quiet.\n\n\n\n\n\n\nBuild, packaging, and runtime improvements\nFocusing on Chrome for Android, we have a uniquely challenging job of building a great browser for every single variant of Android device. In this release we’re taking advantage of some packaging and runtime optimizations to deliver better performance in the Chrome that is in your pocket.\n\n\nSome new Play and Android capabilities allowed us to repackage Chrome on Android, and we’re seeing fewer crashes due to resource exhaustion, a 5% improvement in memory usage, 7.5% faster startup times, and up to 2% faster page loads. Android App Bundles allow the Play Store to generate optimized APKs for each user’s device configuration, and allows packaging code and resources in split APKs, which are installed alongside the base APK. And an Android O feature, isolatedSplits, allows these feature splits to be loaded on demand, reducing Chrome’s overall startup cost.\n\n\nFor those of you who picked up the latest Android devices (Android Q+ and 8GB+ of RAM), we’ve rebuilt Chrome as a 64-bit binary, giving you a more stable Chrome that is up to 8.5% faster to load pages and 28% smoother when it comes to scrolling and input latency.\n\n\nFinally, we’ve built a way for Chrome on Android to start up 13% faster: Freeze-Dried Tabs. Chrome now saves a lightweight version of your tabs that are similar in size to a screenshot, but support scrolling, zooming, and tapping on links. We use these Freeze-Dried Tabs at startup while the actual tab loads in the background, getting you to your pages faster. See it in action below:\n\n\n\n\n\nOur teams are always working hard to bring you the fastest and most powerful browser on every one of your devices. We’re very excited to bring you these performance improvements and have much more to come, so stay tuned.\n\n\nPosted by Mark Chang, Chrome Product Manager\n\n\nData source for all statistics: Real-world data anonymously aggregated from Chrome clients.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-390834330844023092",
        "isoDate": "2021-03-11T17:27:00.001Z"
    },
    {
        "title": " Speeding up Chrome's release cycle",
        "link": "http://blog.chromium.org/2021/03/speeding-up-release-cycle.html",
        "pubDate": "2021-03-04T18:00:00.002Z",
        "author": "Chromium Blog",
        "content": "<div>For more than a decade, Chrome has shipped a new milestone every 6 weeks, delivering security, stability, speed and simplicity to our users and the web. As we have improved our testing and release processes for Chrome, and deployed bi-weekly security updates to improve our <a href=\"https://groups.google.com/a/chromium.org/g/security-dev/c/fbiuFbW07vI\" target=\"_blank\">patch gap</a>, it became clear that we could shorten our release cycle and deliver new features more quickly. Because of this, we are excited to announce that Chrome is planning to move to releasing a new milestone every 4 weeks, starting with Chrome 94 in Q3 of 2021.</div><div><br /></div><div><br /></div><div>Additionally, we will add a new Extended Stable option, with milestone updates every 8 weeks. Extended Stable will be available to enterprise administrators and Chromium embedders who need additional time to manage updates. Security updates on Extended Stable will be released every two weeks to fix important issues, but those updates won’t contain new features or all security fixes that the 4 week option will receive.&nbsp;</div><div><br /></div><div><br /></div><div>For users on Chrome OS, we also plan to support multiple stable release options. We’ll have more to share with Chrome OS administrators in the coming months about the choices you’ll have for milestone updates to your managed devices.</div><div><br /></div><div><br /></div><div>We have updated the <a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/process/release_cycle.md\" target=\"_blank\">documentation for our new release schedule</a>, and we welcome feedback from Chromium contributors at <a href=\"https://groups.google.com/a/chromium.org/g/branches\">branches@chromium.org</a>. We’ve also published a preliminary update to <a href=\"https://chromiumdash.appspot.com/schedule\" target=\"_blank\">our release</a> calendar that we’ll keep up to date as we get closer to launching our new release schedule.</div><div><br /></div><div><br /></div><div>We’re excited to continue evolving Chrome, and providing the best in security, stability, speed and simplicity to our users, even more rapidly in the future!</div><div><br /></div><div><br /></div><div>Alex Mineer, Technical Program Manager, Chrome Operations</div><div><br /></div>",
        "contentSnippet": "For more than a decade, Chrome has shipped a new milestone every 6 weeks, delivering security, stability, speed and simplicity to our users and the web. As we have improved our testing and release processes for Chrome, and deployed bi-weekly security updates to improve our patch gap, it became clear that we could shorten our release cycle and deliver new features more quickly. Because of this, we are excited to announce that Chrome is planning to move to releasing a new milestone every 4 weeks, starting with Chrome 94 in Q3 of 2021.\n\n\n\nAdditionally, we will add a new Extended Stable option, with milestone updates every 8 weeks. Extended Stable will be available to enterprise administrators and Chromium embedders who need additional time to manage updates. Security updates on Extended Stable will be released every two weeks to fix important issues, but those updates won’t contain new features or all security fixes that the 4 week option will receive. \n\n\n\nFor users on Chrome OS, we also plan to support multiple stable release options. We’ll have more to share with Chrome OS administrators in the coming months about the choices you’ll have for milestone updates to your managed devices.\n\n\n\nWe have updated the documentation for our new release schedule, and we welcome feedback from Chromium contributors at branches@chromium.org. We’ve also published a preliminary update to our release calendar that we’ll keep up to date as we get closer to launching our new release schedule.\n\n\n\nWe’re excited to continue evolving Chrome, and providing the best in security, stability, speed and simplicity to our users, even more rapidly in the future!\n\n\n\nAlex Mineer, Technical Program Manager, Chrome Operations",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-8727227945090075031",
        "isoDate": "2021-03-04T18:00:00.002Z"
    },
    {
        "title": "Heads Up: Restriction on SharedArrayBuffers are coming in M91",
        "link": "http://blog.chromium.org/2021/02/restriction-on-sharedarraybuffers.html",
        "pubDate": "2021-02-17T16:00:00.002Z",
        "author": "Chromium Blog",
        "content": "<h4 style=\"text-align: left;\"><i style=\"font-weight: normal;\">May 10, 2021: Based on last minute feedback received by developers we’re <a href=\"https://blog.chromium.org/2021/05/adjusted-timeline-for-sharedarraybuffers.html\" target=\"_blank\">adjusting the timeline</a> to restrict SharedArrayBuffers in M92 - not as planned in M91. One of our goals for this migration is a smooth transition, therefore we’ve decided to adjust the timeline of this change and will support the reverse origin trial via <meta></meta> tag as well.</i></h4>  <p>Starting in Chrome 91 (May, 2021), <a href=\"https://developer.chrome.com/blog/enabling-shared-array-buffer/#cross-origin-isolation\" target=\"_blank\">cross-origin isolation</a> will be required on all platforms in order to access APIs like <span style=\"font-family: courier;\">SharedArrayBuffer</span> and <a href=\"https://web.dev/monitor-total-page-memory-usage/\" target=\"_blank\">performance.measureUserAgentSpecificMemory()</a>. This brings our desktop platforms in line with Android, which shipped this restriction in Chrome 88.</p>      <p>In order to continue using these APIs, ensure that your pages are cross-origin isolated by serving the page with the following headers:</p> <code>  <pre>Cross-Origin-Embedder-Policy: require-corp<br />Cross-Origin-Opener-Policy: same-origin</pre></code>    <p>Be aware, once you do this, your page will not be able to load cross-origin content unless the resource explicitly allows it via a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)\" target=\"_blank\">Cross-Origin-Resource-Policy</a> header or <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" target=\"_blank\">CORS</a> headers (Access-Control-Allow-* and so forth).</p>  <p>For more detailed adoption instructions and considerations, take a look at the <a href=\"https://web.dev/cross-origin-isolation-guide/\" target=\"_blank\">web.dev guide to enable cross-origin isolation</a>.</p> <span class=\"post-author\">Posted by Lutz Vahl, Technical Program Manager</span>",
        "contentSnippet": "May 10, 2021: Based on last minute feedback received by developers we’re adjusting the timeline to restrict SharedArrayBuffers in M92 - not as planned in M91. One of our goals for this migration is a smooth transition, therefore we’ve decided to adjust the timeline of this change and will support the reverse origin trial via  tag as well.\n  \nStarting in Chrome 91 (May, 2021), cross-origin isolation will be required on all platforms in order to access APIs like SharedArrayBuffer and performance.measureUserAgentSpecificMemory(). This brings our desktop platforms in line with Android, which shipped this restriction in Chrome 88.\n      \nIn order to continue using these APIs, ensure that your pages are cross-origin isolated by serving the page with the following headers:\n   \nCross-Origin-Embedder-Policy: require-corp\nCross-Origin-Opener-Policy: same-origin\n    \nBe aware, once you do this, your page will not be able to load cross-origin content unless the resource explicitly allows it via a Cross-Origin-Resource-Policy header or CORS headers (Access-Control-Allow-* and so forth).\n  \nFor more detailed adoption instructions and considerations, take a look at the web.dev guide to enable cross-origin isolation.\n Posted by Lutz Vahl, Technical Program Manager",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-1083322362215661363",
        "isoDate": "2021-02-17T16:00:00.002Z"
    },
    {
        "title": "Chrome 89 Beta: Advanced Hardware Interactions, Web Sharing on Desktop, and More",
        "link": "http://blog.chromium.org/2021/01/chrome-89-beta-advanced-hardware.html",
        "pubDate": "2021-01-28T19:40:00.006Z",
        "author": "Chromium Blog",
        "content": "<p>Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on <a href=\"https://www.chromestatus.com/features#milestone%3D89\">ChromeStatus.com</a>. Chrome 89 is beta as of January 28, 2021.</p> <h1>WebHID API</h1><p>There is a long tail of human interface devices (HIDs) that are too new, too old, or too uncommon to be accessible by systems' device drivers. The WebHID API solves this by providing a way to implement device-specific logic in JavaScript. </p> <p>A human interface device is one that takes input from or provides output to humans. Examples of devices include keyboards, pointing devices (mice, touchscreens, etc.), and gamepads.</p> <p>The inability to access uncommon or unusual HID devices is particularly painful, for example, when it comes to gamepad support. Gamepad inputs and outputs are not well standardized and web browsers often require custom logic for specific devices. This is unsustainable and results in poor support for the long tail of older and uncommon devices.</p> <p>With its origin trial over, WebHID is enabled by default in Chrome 89 on desktop. To learn how to use it, check out <a href=\"https://web.dev/hid/\">Connecting to uncommon HID devices</a>, and see demos in <a href=\"https://web.dev/hid-examples\">Human interface devices on the web: a few quick examples</a>.</p> <h1>Web NFC</h1><p>NFC stands for Near Field Communications, a short-range wireless technology for transmitting small amounts of data, usually between a specialized NFC device and a reader. If you've scanned a badge to enter a building, you may have used NFC. </p> <p>Web NFC allows a web app to read from and write to NFC tags. This opens new use cases to the web, including providing information about museum exhibits, inventory management, providing information in a conference badge, and many others. In Chrome 89 on Android, Web NFC is enabled by default.</p><p><span id=\"docs-internal-guid-de5ab4e0-7fff-cc98-97d2-2de8435c1c8a\"><span style=\"font-family: Arial; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"border: none; display: inline-block; height: 352px; overflow: hidden; width: 624px;\"><img height=\"352\" src=\"https://lh6.googleusercontent.com/VlnOVtjnGZY0xdkA__MVrqrm62y0hVs8-qsW17ZDlc9PhKBDpMHjZ4x0grAPEVgF6MGf80H2FQNrBhPvKaq4-QkA6ddk29bpZj8mNnnSiBsCBq9MidJy6xT5aVfIAbf5-pXduFTDE6wmAQ6cJlw6PJRnRcr8O7y3TRu7V_DGFBEmqqrw\" style=\"margin-left: 0px; margin-top: 0px;\" width=\"624\" /></span></span></span></p> <p><em>Web NFC cards demo at Chrome Dev Summit</em></p> <p>With NFC reading and writing are simple operations. You'll need a little instruction for constructing and interpreting payloads, but it's not complicated. Fortunately, we have an article, <a href=\"https://web.dev/nfc\">Interact with NFC devices on the web</a>. Check it out. We have <a href=\"https://googlechrome.github.io/samples/web-nfc/\">some samples</a> you can play with. Here's a taste:</p> <p>Writing a string to an NFC tag:</p> <code><pre>if (\"NDEFReader\" in window) {<br />  const ndef = new NDEFReader();<br />  await ndef.write(\"Hello world!\");<br />}</pre></code> <p>Scanning messages from NFC tags:</p> <code><pre>if (\"NDEFReader\" in window) {<br />  const ndef = new NDEFReader();<br />  await ndef.scan();<br />  ndef.onreading = ({ message }) =&gt; {<br />    console.log(`Records read from a NFC tag: ${message.records.length}`);<br />  };<br />}</pre></code> <h1>Web Serial API</h1><p>A serial port is a bidirectional communication interface that allows sending and receiving data byte by byte. The Web Serial API brings this capability to websites, letting them control devices such as microcontrollers and 3D printers.</p> <p>In educational, hobbyist, and industrial settings, peripheral devices are already controlled through web pages. In all such cases device control requires installation of adapters and drivers. The Web Serial API improves the user experience by enabling direct communication between a website and a peripheral. </p> <p>Its origin trial is over and the Web Serial API is now enabled on desktop. A <a href=\"https://googlechromelabs.github.io/serial-terminal/\">demo is available</a> on GitHub. For information about using it, see <a href=\"https://web.dev/serial/\">Read to and write from a serial port</a>. </p> <h1>Web Sharing on Desktop</h1><p>To allow users to easily share content on social networks, developers have manually integrated sharing buttons into their site for each social service. This often leads to users not being able to share with the services they actually use, in addition to bloated page sizes and security risks from third-party code. On the receiving end, only platform apps could register to be share targets and receive shares from other apps.  </p> <p>Chrome for Android started adding these features between Chrome 61 and 75. In Chrome 89, web sharing is available on Windows and ChromeOS, while registering as a share target is supported on ChromeOS. On these platforms, sites can now use <code>navigator.share()</code> on desktop to trigger a share dialog box. And an entry to the web app manifest allows a PWA to act as a share target. </p> <p>For information on web sharing, see <a href=\"https://web.dev/web-share/\">Integrate with the OS sharing UI with the Web Share API</a>. To learn to configure a PWA as a share target, see <a href=\"https://web.dev/web-share-target/\">Receiving shared data with the Web Share Target API</a>.</p> <h1>Origin Trials</h1><p>There are no new origin trials in this version of Chrome. To register for current origin trials, visit the <a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Origin Trials dashboard</a>. To learn more about origin trials themselves, visit the <a href=\"https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md\">Origin Trials Guide for Web Developers</a>.</p> <h1>Other features in this release</h1> <h2>AVIF Image Decode</h2><p>Chrome now supports&nbsp;<a href=\"https://www.chromestatus.com/feature/4905307790639104\">decoding AVIF content</a> natively using existing AV1 decoders on Android and WebView. (Desktop support was added in Chrome 85.)  AVIF is a next generation image format standardized by the <a href=\"https://aomedia.org/\">Alliance for Open Media</a>. There are three primary motivations for supporting AVIF:</p> <ul><li>Reducing bandwidth consumption to load pages faster and reduce overall data consumption. AVIF offers significant file size reduction for images compared with JPEG or WebP.</li><li>Adding HDR color support. AVIF is a path to HDR image support for the web. JPEG is limited in practice to 8-bit color depth. With displays increasingly capable of higher brightness, color bit depth, and color gamuts, web stakeholders are increasingly interested in preserving image data that is lost with JPEG.</li><li>Supporting ecosystem interest. Companies with a large web presence have expressed an interest in shipping AVIF images on the web.</li></ul> <h2>Cross-origin opener policy reporting API</h2><p><a href=\"https://www.chromestatus.com/feature/5755687994916864\">A new reporting API</a>&nbsp;helps developers deploy <a href=\"https://web.dev/coop-coep/\">cross-origin opener policy</a>. In addition to reporting breakages when COOP is enforced, the API provides a report-only mode for COOP. The report-only mode for COOP will not enforce COOP, but it will report potential breakages that would have happened had we enforced COOP. Developers can inspect the <a href=\"https://developers.google.com/web/updates/2020/10/devtools#frame-details\">reporting API</a> with Chrome DevTools.</p> <h2>Display override in web app manifests</h2><p>The new&nbsp;<code>display_override</code> field for the web app manifest allows developers to specify an explicit fallback chain for the <code>display</code> field. The following example specifies a <code>\"minimal-ui\"</code>, falling back to <code>\"standalone\"</code>.</p> <code><pre>{<br />  \"display\": \"standalone\",<br />  \"display_override\": [\"minimal-ui\"],<br />}</pre></code> <p>This API is intended for advanced use cases and display modes, and its capabilities are limited. You can learn more in its <a href=\"https://www.chromestatus.com/feature/5728570678706176\">Chrome Status entry</a>.</p> <h2>Expose ReadableStreamDefaultController interface</h2><p>Chrome now <a href=\"https://www.chromestatus.com/feature/5711333280448512\">exposes the <code>ReadableStreamDefaultController</code> interface on the global object</a>, as with the other ReadableStream-related classes. This eliminates a previous limitation where instances had to be created inside stream constructors.</p> <h2>performance.measureUserAgentSpecificMemory() </h2><p>The feature adds a <a href=\"https://www.chromestatus.com/feature/5685965186138112\"><code>performance.measureUserAgentSpecificMemory()</code> function</a> which estimates the memory usage of the web page. The method is gated behind COOP/COEP thus the web site needs to be <a href=\"https://web.dev/why-coop-coep/\">cross-origin isolated</a> to use it.</p> <h2>Potentially trustworthy data: urls </h2><p>To conform to current web standards, Chrome now <a href=\"https://www.chromestatus.com/feature/5634194258526208\">treats all data: urls as potentially trustworthy</a>. <br />For background, It's often necessary to evaluate whether a URL is secure in order to only enable certain features when minimum standards of authentication and confidentiality are met. For that purpose, web standards rely on the definition of \"potentially trustworthy URL\", which includes URLs with the \"data\" scheme in the latest version of the Secure Contexts specification. Blink previously only treated some data: URLs as potential trustworthy. </p> <h2>Streams API: Byte Streams</h2><p>The streams APIs provide ubiquitous, interoperable primitives for creating, composing, and consuming streams of data. For streams representing bytes, Chrome now supports <a href=\"https://www.chromestatus.com/feature/4535319661641728\">an extended version of the readable stream</a> to handle bytes efficiently, specifically by minimizing copies.</p><p><br />Byte streams allow for Bring Your Own Buffer (BYOB) readers to be acquired. The default implementation can give a range of different outputs such as strings or array buffers in the case of web sockets, whereas byte streams guarantee byte output. Furthermore, being able to have BYOB readers has stability benefits. This is because if a buffer detaches, there's now a guarantee that the same buffer won't be written to twice, hence avoiding race conditions. BYOB readers also do not need to garbage collect for every read, because buffers are reused.</p> <h2>Support for full 'filter' property syntax on SVG elements</h2><p>Chrome now <a href=\"https://www.chromestatus.com/feature/5076637643177984\">allows the full syntax of the <code>'filter'</code> property</a> to be used on SVG elements which previously only supported single <code>url()</code> references. This lets filter functions such as <code>blur()</code>, <code>sepia()</code> and <code>grayscale()</code> apply to both SVG elements and non-SVG elements. It makes the platform support for <code>'filter'</code> more uniform and allows for easier application of some \"canned\" effects. Without this feature developers need to use a full SVG <code>&lt;filter&gt;</code> element definition even for basic filters such as <code>grayscale()</code> or <code>blur()</code>.</p> <h2>WebAuthentication API: ResidentKeyRequirement and credProps extension</h2><p>Chrome now supports<a href=\"https://www.chromestatus.com/feature/5701094648840192\"> two new features related to the Web Authentication API</a>. The <code>AuthenticatorSelectionCriteria.residentKey</code> property specifies for web authentication credential registration whether a client-side discoverable credential should be created. </p> <p>The Web Authentication <code>credProps</code> extension indicates to the relying party whether a created credential is client-side discoverable. \"Client-side discoverable credentials\" are a type of WebAuthn credential that can be challenged by a relying party without needing to provide the credential ID in the WebAuthn API request. Browsers display a list of all discoverable credentials from a given authenticator (either external security key or built-in) and let the user choose one to sign in with.</p> <h1>CSS</h1> <h2>::target-text pseudo-element</h2><p>Adds <a href=\"https://www.chromestatus.com/feature/5689463273422848\">a highlight pseudo element</a> to allow authors to style <a href=\"https://chromestatus.com/feature/4733392803332096\"><code>scroll-to-text</code> fragments</a> differently from the default user agent highlighting.</p> <h2>flow-relative Corner Rounding properties</h2><p><a href=\"https://www.chromestatus.com/feature/5631002091192320\">Flow-relative corner rounding properties</a> now allow control of corners using logical mappings rather than physical properties. Additionally, this allows authors to set different corner border radii depending on the direction and writing mode of the page.This brings Chrome in line with the <a href=\"https://drafts.csswg.org/css-logical/\">CSS Logical Properties and Values</a> spec. The following logical properties have been added: </p><ul><li><code>border-start-start-radius</code></li><li><code>border-start-end-radius</code></li><li><code>border-end-start-radius</code></li><li><code>border-end-end-radius</code></li></ul> <h2>Forced colors property</h2><p><a href=\"https://www.chromestatus.com/feature/5757293075365888\">The <code>forced-colors</code> media feature</a> detects whether the user agent is enforcing a user-chosen limited color palette on the page.</p> <h2>Forced colors adjust property</h2><p><a href=\"https://www.chromestatus.com/feature/5757293075365888\">The <code>forced-color-adjust</code> property</a> allows authors to opt particular elements out of forced colors mode, restoring full control over the colors to CSS.</p> <h1>JavaScript</h1><p>This version of Chrome incorporates version 8.9 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete <a href=\"https://v8.dev/blog\">list of recent features</a> in the V8 release notes.</p> <h2>Top-level await</h2><p>Chrome now <a href=\"https://www.chromestatus.com/feature/5767881411264512\">allows the <code>await</code> keyword at the top level</a> within JavaScript modules. This allows more seamless integration of asynchronous calls into the module loading process. Today this is accomplished by wrapping modules in async functions, but this pushes complexity into dependent modules and exposes implementation details.</p> <h1>Developer Notes</h1> <h2>Image Orientation with EXIF</h2><p>EXIF information is now always used to <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=1110330\">orient cross-origin images</a>. That is, setting <code>image-orientation: none</code> in CSS has no effect on non-secure-origin images. The spec discussion behind the change is available in <a href=\"https://github.com/w3c/csswg-drafts/issues/5165\">a CSS working group draft</a>.</p> <h1>Deprecations and Removals</h1><p>This version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of <a href=\"https://www.chromestatus.com/features#browsers.chrome.status%3A%22Deprecated%22\">current deprecations</a>  and <a href=\"https://www.chromestatus.com/features#browsers.chrome.status:%22Removed%22\">previous removals</a>.</p> <h2>Remove prefixed events for &lt;link rel=prerender&gt;</h2><p>The legacy prefixed events (<code>webkitprerenderstart</code>, <code>webkitprerenderstop</code>, <code>webkitprerenderload</code>, and <code>webkitprerenderdomcontentloaded</code>) dispatched on <code>&lt;link rel=prerender&gt;</code> <a href=\"https://www.chromestatus.com/feature/4925917174431744\">are now removed from Chrome</a>.</p> <h2>Stop cloning sessionStorage for windows opened with noopener</h2><p>When a window is opened with noopener, Chrome will <a href=\"https://www.chromestatus.com/feature/5679997870145536\">no longer clone the <code>sessionStorage</code></a> of its opener; it will instead start an empty <code>sessionStorage</code> namespace. This brings Chrome in conformance with the HTML specification.</p>",
        "contentSnippet": "Unless otherwise noted, changes described below apply to the newest Chrome beta channel release for Android, Chrome OS, Linux, macOS, and Windows. Learn more about the features listed here through the provided links or from the list on ChromeStatus.com. Chrome 89 is beta as of January 28, 2021.\n WebHID API\nThere is a long tail of human interface devices (HIDs) that are too new, too old, or too uncommon to be accessible by systems' device drivers. The WebHID API solves this by providing a way to implement device-specific logic in JavaScript. \n A human interface device is one that takes input from or provides output to humans. Examples of devices include keyboards, pointing devices (mice, touchscreens, etc.), and gamepads.\n The inability to access uncommon or unusual HID devices is particularly painful, for example, when it comes to gamepad support. Gamepad inputs and outputs are not well standardized and web browsers often require custom logic for specific devices. This is unsustainable and results in poor support for the long tail of older and uncommon devices.\n With its origin trial over, WebHID is enabled by default in Chrome 89 on desktop. To learn how to use it, check out Connecting to uncommon HID devices, and see demos in Human interface devices on the web: a few quick examples.\n Web NFC\nNFC stands for Near Field Communications, a short-range wireless technology for transmitting small amounts of data, usually between a specialized NFC device and a reader. If you've scanned a badge to enter a building, you may have used NFC. \n Web NFC allows a web app to read from and write to NFC tags. This opens new use cases to the web, including providing information about museum exhibits, inventory management, providing information in a conference badge, and many others. In Chrome 89 on Android, Web NFC is enabled by default.\n\n Web NFC cards demo at Chrome Dev Summit\n With NFC reading and writing are simple operations. You'll need a little instruction for constructing and interpreting payloads, but it's not complicated. Fortunately, we have an article, Interact with NFC devices on the web. Check it out. We have some samples you can play with. Here's a taste:\n Writing a string to an NFC tag:\n \nif (\"NDEFReader\" in window) {\n  const ndef = new NDEFReader();\n  await ndef.write(\"Hello world!\");\n} \nScanning messages from NFC tags:\n \nif (\"NDEFReader\" in window) {\n  const ndef = new NDEFReader();\n  await ndef.scan();\n  ndef.onreading = ({ message }) => {\n    console.log(`Records read from a NFC tag: ${message.records.length}`);\n  };\n} \nWeb Serial API\nA serial port is a bidirectional communication interface that allows sending and receiving data byte by byte. The Web Serial API brings this capability to websites, letting them control devices such as microcontrollers and 3D printers.\n In educational, hobbyist, and industrial settings, peripheral devices are already controlled through web pages. In all such cases device control requires installation of adapters and drivers. The Web Serial API improves the user experience by enabling direct communication between a website and a peripheral. \n Its origin trial is over and the Web Serial API is now enabled on desktop. A demo is available on GitHub. For information about using it, see Read to and write from a serial port. \n Web Sharing on Desktop\nTo allow users to easily share content on social networks, developers have manually integrated sharing buttons into their site for each social service. This often leads to users not being able to share with the services they actually use, in addition to bloated page sizes and security risks from third-party code. On the receiving end, only platform apps could register to be share targets and receive shares from other apps.  \n Chrome for Android started adding these features between Chrome 61 and 75. In Chrome 89, web sharing is available on Windows and ChromeOS, while registering as a share target is supported on ChromeOS. On these platforms, sites can now use navigator.share() on desktop to trigger a share dialog box. And an entry to the web app manifest allows a PWA to act as a share target. \n For information on web sharing, see Integrate with the OS sharing UI with the Web Share API. To learn to configure a PWA as a share target, see Receiving shared data with the Web Share Target API.\n Origin Trials\nThere are no new origin trials in this version of Chrome. To register for current origin trials, visit the Origin Trials dashboard. To learn more about origin trials themselves, visit the Origin Trials Guide for Web Developers.\n Other features in this release\n AVIF Image Decode\nChrome now supports decoding AVIF content natively using existing AV1 decoders on Android and WebView. (Desktop support was added in Chrome 85.)  AVIF is a next generation image format standardized by the Alliance for Open Media. There are three primary motivations for supporting AVIF:\n \nReducing bandwidth consumption to load pages faster and reduce overall data consumption. AVIF offers significant file size reduction for images compared with JPEG or WebP.\nAdding HDR color support. AVIF is a path to HDR image support for the web. JPEG is limited in practice to 8-bit color depth. With displays increasingly capable of higher brightness, color bit depth, and color gamuts, web stakeholders are increasingly interested in preserving image data that is lost with JPEG.\nSupporting ecosystem interest. Companies with a large web presence have expressed an interest in shipping AVIF images on the web.\n \nCross-origin opener policy reporting API\nA new reporting API helps developers deploy cross-origin opener policy. In addition to reporting breakages when COOP is enforced, the API provides a report-only mode for COOP. The report-only mode for COOP will not enforce COOP, but it will report potential breakages that would have happened had we enforced COOP. Developers can inspect the reporting API with Chrome DevTools.\n Display override in web app manifests\nThe new display_override field for the web app manifest allows developers to specify an explicit fallback chain for the display field. The following example specifies a \"minimal-ui\", falling back to \"standalone\".\n \n{  \"display\": \"standalone\",\n  \"display_override\": [\"minimal-ui\"],\n} \nThis API is intended for advanced use cases and display modes, and its capabilities are limited. You can learn more in its Chrome Status entry.\n Expose ReadableStreamDefaultController interface\nChrome now exposes the ReadableStreamDefaultController interface on the global object, as with the other ReadableStream-related classes. This eliminates a previous limitation where instances had to be created inside stream constructors.\n performance.measureUserAgentSpecificMemory() \nThe feature adds a performance.measureUserAgentSpecificMemory() function which estimates the memory usage of the web page. The method is gated behind COOP/COEP thus the web site needs to be cross-origin isolated to use it.\n Potentially trustworthy data: urls \nTo conform to current web standards, Chrome now treats all data: urls as potentially trustworthy. \nFor background, It's often necessary to evaluate whether a URL is secure in order to only enable certain features when minimum standards of authentication and confidentiality are met. For that purpose, web standards rely on the definition of \"potentially trustworthy URL\", which includes URLs with the \"data\" scheme in the latest version of the Secure Contexts specification. Blink previously only treated some data: URLs as potential trustworthy. \n Streams API: Byte Streams\nThe streams APIs provide ubiquitous, interoperable primitives for creating, composing, and consuming streams of data. For streams representing bytes, Chrome now supports an extended version of the readable stream to handle bytes efficiently, specifically by minimizing copies.\n\nByte streams allow for Bring Your Own Buffer (BYOB) readers to be acquired. The default implementation can give a range of different outputs such as strings or array buffers in the case of web sockets, whereas byte streams guarantee byte output. Furthermore, being able to have BYOB readers has stability benefits. This is because if a buffer detaches, there's now a guarantee that the same buffer won't be written to twice, hence avoiding race conditions. BYOB readers also do not need to garbage collect for every read, because buffers are reused.\n Support for full 'filter' property syntax on SVG elements\nChrome now allows the full syntax of the 'filter' property to be used on SVG elements which previously only supported single url() references. This lets filter functions such as blur(), sepia() and grayscale() apply to both SVG elements and non-SVG elements. It makes the platform support for 'filter' more uniform and allows for easier application of some \"canned\" effects. Without this feature developers need to use a full SVG <filter> element definition even for basic filters such as grayscale() or blur().\n WebAuthentication API: ResidentKeyRequirement and credProps extension\nChrome now supports two new features related to the Web Authentication API. The AuthenticatorSelectionCriteria.residentKey property specifies for web authentication credential registration whether a client-side discoverable credential should be created. \n The Web Authentication credProps extension indicates to the relying party whether a created credential is client-side discoverable. \"Client-side discoverable credentials\" are a type of WebAuthn credential that can be challenged by a relying party without needing to provide the credential ID in the WebAuthn API request. Browsers display a list of all discoverable credentials from a given authenticator (either external security key or built-in) and let the user choose one to sign in with.\n CSS\n ::target-text pseudo-element\nAdds a highlight pseudo element to allow authors to style scroll-to-text fragments differently from the default user agent highlighting.\n flow-relative Corner Rounding properties\nFlow-relative corner rounding properties now allow control of corners using logical mappings rather than physical properties. Additionally, this allows authors to set different corner border radii depending on the direction and writing mode of the page.This brings Chrome in line with the CSS Logical Properties and Values spec. The following logical properties have been added: \n\nborder-start-start-radius\nborder-start-end-radius\nborder-end-start-radius\nborder-end-end-radius\n \nForced colors property\nThe forced-colors media feature detects whether the user agent is enforcing a user-chosen limited color palette on the page.\n Forced colors adjust property\nThe forced-color-adjust property allows authors to opt particular elements out of forced colors mode, restoring full control over the colors to CSS.\n JavaScript\nThis version of Chrome incorporates version 8.9 of the V8 JavaScript engine. It specifically includes the changes listed below. You can find a complete list of recent features in the V8 release notes.\n Top-level await\nChrome now allows the await keyword at the top level within JavaScript modules. This allows more seamless integration of asynchronous calls into the module loading process. Today this is accomplished by wrapping modules in async functions, but this pushes complexity into dependent modules and exposes implementation details.\n Developer Notes\n Image Orientation with EXIF\nEXIF information is now always used to orient cross-origin images. That is, setting image-orientation: none in CSS has no effect on non-secure-origin images. The spec discussion behind the change is available in a CSS working group draft.\n Deprecations and Removals\nThis version of Chrome introduces the deprecations and removals listed below. Visit ChromeStatus.com for lists of current deprecations  and previous removals.\n Remove prefixed events for <link rel=prerender>\nThe legacy prefixed events (webkitprerenderstart, webkitprerenderstop, webkitprerenderload, and webkitprerenderdomcontentloaded) dispatched on <link rel=prerender> are now removed from Chrome.\n Stop cloning sessionStorage for windows opened with noopener\nWhen a window is opened with noopener, Chrome will no longer clone the sessionStorage of its opener; it will instead start an empty sessionStorage namespace. This brings Chrome in conformance with the HTML specification.",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-1837784016188725419",
        "isoDate": "2021-01-28T19:40:00.006Z"
    },
    {
        "title": "Privacy Sandbox in 2021: Testing a more private web",
        "link": "http://blog.chromium.org/2021/01/privacy-sandbox-in-2021.html",
        "pubDate": "2021-01-25T12:58:00.001Z",
        "author": "Chromium Blog",
        "content": "<span>A year ago we <a href=\"https://blog.chromium.org/2020/01/building-more-private-web-path-towards.html\" target=\"_blank\">announced</a> our intention to phase out third-party cookies and replace them with new browser features that are fundamentally more private. Since then, we've been working closely with the broader web community, including W3C, to design and implement new privacy-preserving technology, while also preserving the vitality and sustainability of the open web.<br /><br />Today more than 30 different proposals have been offered by Chrome and others, including many that we believe are key to rendering third-party cookies obsolete. Early test results are also looking promising (see below)!<br /><br />We are excited to continue testing this foundational tech with the active involvement of ecosystem partners and industry forums –&nbsp;all to move the web forward, together. What follows are key updates since our announcements last <a href=\"https://blog.chromium.org/2020/01/building-more-private-web-path-towards.html\" target=\"_blank\">January</a> and <a href=\"https://blog.chromium.org/2020/10/progress-on-privacy-sandbox-and.html\" target=\"_blank\">October</a>.<br /><br /><br /></span><h3 style=\"text-align: left;\"><span style=\"font-size: medium;\">Early results, and new proposals ready for testing</span></h3><span><br />Five different Privacy Sandbox proposals are available for testing now&nbsp;– or will be very soon – in key areas like fraud detection, the tailoring of content, first-party treatment of a company’s owned and related domains, ads measurement, and a private-by-default way to request browser info. In fact, early testing of the <a href=\"https://github.com/WICG/floc\" target=\"_blank\"><b>Federated Learning of Cohorts (FloC) algorithm</b></a> shows that new privacy-preserving ad solutions can be <a href=\"https://blog.google/products/ads-commerce/2021-01-privacy-sandbox\" target=\"_blank\">similarly effective to cookie-based approaches</a>. This is great news for users, publishers, and advertisers –&nbsp;all of whom are critical for the future of the web –&nbsp;so we’re excited to carry this work forward.<br /><br /><br />Another important area of focus is user-facing controls. In particular, it’s clear that people will want to tune whether content is tailored to them (or not) –&nbsp;in addition to keeping their private info private. With the Chrome 90 release in April, we’ll be releasing the first controls for the Privacy Sandbox (first, a simple on/off), and we plan to expand on these controls in future Chrome releases, as more proposals reach the origin trial stage, and we receive more feedback from end users and industry.  You can find a full update on all trials on our <a href=\"http://developer.chrome.com/blog/privacy-sandbox-update-2021-jan\" target=\"_blank\">blog</a>.<br /><br /><br /></span><h3 style=\"text-align: left;\"><span style=\"font-size: medium;\">Involvement across the ecosystem</span></h3><span><br />It’s great to see companies like Salesforce, White Ops, and Yahoo! JAPAN, starting (or preparing) to test initial solutions like <a href=\"https://web.dev/trust-tokens/\" target=\"_blank\"><b>Trust Tokens</b></a>, <a href=\"https://github.com/privacycg/first-party-sets\" target=\"_blank\"><b>First Party Sets</b></a>, and <a href=\"https://web.dev/conversion-measurement/\" target=\"_blank\"><b>Conversion Measurement</b></a>. In fact, all developers have access to public Chrome experiments, and the latest guidance can be found on <a href=\"https://web.dev/origin-trials/\">web.dev</a>, so please do test and <a href=\"http://developer.chrome.com/blog/privacy-sandbox-participate\" target=\"_blank\">share feedback</a>. This type of engagement helps ensure that the various APIs work as expected in real-world scenarios, so the more ecosystem participation, the better!<br /><br /><br /></span><h3 style=\"text-align: left;\"><span style=\"font-size: medium;\">Building better. Together.</span></h3><span><br />One of the things that makes the web so great is that it’s by and for all of us; this is a special quality amongst today’s platforms, and is definitely worth celebrating! It also creates complexity and trade-offs that we have to manage thoughtfully – and collectively –&nbsp;as we introduce new technology. That’s why we continue to engage in industry forums like the W3C, and are in active discussions with independent authorities –&nbsp; including privacy regulators and the UK’s Competition and Markets Authority –&nbsp;to help identify and shape the best approach for online privacy, and the industry and world as a whole.<br /><br /><br />So here’s to the users, and coders, and advertisers, and content creators (and so many others) who’ve made, and continue to make the platform what it is today. And here’s to coming together, in service of a more private web.<br /><br /><br />Posted by Justin Schuh - Director, Chrome Engineering</span><span class=\"post-author\"><div><span class=\"post-author\"><br /></span></div><br /></span>",
        "contentSnippet": "A year ago we announced our intention to phase out third-party cookies and replace them with new browser features that are fundamentally more private. Since then, we've been working closely with the broader web community, including W3C, to design and implement new privacy-preserving technology, while also preserving the vitality and sustainability of the open web.\nToday more than 30 different proposals have been offered by Chrome and others, including many that we believe are key to rendering third-party cookies obsolete. Early test results are also looking promising (see below)!\nWe are excited to continue testing this foundational tech with the active involvement of ecosystem partners and industry forums – all to move the web forward, together. What follows are key updates since our announcements last January and October.\n\n\nEarly results, and new proposals ready for testing\n\nFive different Privacy Sandbox proposals are available for testing now – or will be very soon – in key areas like fraud detection, the tailoring of content, first-party treatment of a company’s owned and related domains, ads measurement, and a private-by-default way to request browser info. In fact, early testing of the Federated Learning of Cohorts (FloC) algorithm shows that new privacy-preserving ad solutions can be similarly effective to cookie-based approaches. This is great news for users, publishers, and advertisers – all of whom are critical for the future of the web – so we’re excited to carry this work forward.\n\nAnother important area of focus is user-facing controls. In particular, it’s clear that people will want to tune whether content is tailored to them (or not) – in addition to keeping their private info private. With the Chrome 90 release in April, we’ll be releasing the first controls for the Privacy Sandbox (first, a simple on/off), and we plan to expand on these controls in future Chrome releases, as more proposals reach the origin trial stage, and we receive more feedback from end users and industry.  You can find a full update on all trials on our blog.\n\n\nInvolvement across the ecosystem\n\nIt’s great to see companies like Salesforce, White Ops, and Yahoo! JAPAN, starting (or preparing) to test initial solutions like Trust Tokens, First Party Sets, and Conversion Measurement. In fact, all developers have access to public Chrome experiments, and the latest guidance can be found on web.dev, so please do test and share feedback. This type of engagement helps ensure that the various APIs work as expected in real-world scenarios, so the more ecosystem participation, the better!\n\n\nBuilding better. Together.\n\nOne of the things that makes the web so great is that it’s by and for all of us; this is a special quality amongst today’s platforms, and is definitely worth celebrating! It also creates complexity and trade-offs that we have to manage thoughtfully – and collectively – as we introduce new technology. That’s why we continue to engage in industry forums like the W3C, and are in active discussions with independent authorities –  including privacy regulators and the UK’s Competition and Markets Authority – to help identify and shape the best approach for online privacy, and the industry and world as a whole.\n\nSo here’s to the users, and coders, and advertisers, and content creators (and so many others) who’ve made, and continue to make the platform what it is today. And here’s to coming together, in service of a more private web.\n\nPosted by Justin Schuh - Director, Chrome Engineering",
        "id": "tag:blogger.com,1999:blog-2471378914199150966.post-8041122391476262060",
        "isoDate": "2021-01-25T12:58:00.001Z"
    }
]